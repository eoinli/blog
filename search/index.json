[{"content":" 出处：NOI 2020 题面与评测地址：洛谷 P6772 \u0026amp; LibreOJ #3339 参考题解：By Plozia 暴力部分分 先考虑朴素做法如何实现。根据题目的设问方式可以发现，这道题需要用到动态规划进行解决。于是我们可以设计这样一个状态：$f_{t, v}$，它表示第 $t$ 天走到了城市 $v$ 时所能持有的最大愉悦值。令图中起点为 $u$、终点为 $v$、耗时为 $w$ 的有向边为 $(u, v, w)$，则该状态的转移满足：\n$$ f_{t, v} = \\max_{(u, v, w) \\in E} \\left\\lbrace f_{t - w, u} \\right\\rbrace + c_v + \\text{fest}_{t, v} $$\n其中，$\\text{fest}_{t, v}$ 为在第 $t$ 天城市 $v$ 所举办的美食节的加成。若这一天在这座城市没有美食节举办，该值等于 $0$。当然，实际编码时还要考虑 $i - w$ 不小于 $1$ 等等问题，这里就不详述了。仅仅是这样暴力的 $\\mathcal{O}\\left (Tn\\right )$ 复杂度的 DP，也可以拿到 40 分，这充分说明了好好打部分分的重要性 😮\n矩阵优化的引入 假设现在所有边的边权 $w$ 均为 $1$，且暂时不考虑美食节的影响，即 $k = 0$。那么原问题简化为：在一个 $n$ 点 $m$ 边的图中，恰好经过 $p$ 条边的最长路。沿用此前的转移，我们有：\n$$ \\begin{aligned} f_{t, v} \u0026amp;= \\max \\left\\lbrace f_{t - w, u} \\right\\rbrace + c_v + \\text{fest} _ {t, v} \\newline \u0026amp;= \\max \\left\\lbrace f_{t - 1, u} \\right\\rbrace + c_v \\newline \u0026amp;= \\max \\left\\lbrace f_{t - 1, u} + c_v \\right\\rbrace \\end{aligned} $$\n这里的 $c_v$ 可看作是每个点的点权，考虑将其转化为边权，令 $d_{u, v}$ 表示起点为 $u$、终点为 $v$ 的边中，终点 $v$ 的愉悦值 $c_v$。那么上式就可以写为\n$$ f_{t, v} = \\max\\left\\lbrace f_{t - 1, u} + d_{u, v} \\right\\rbrace $$\n你可能会发现，这样的形式与矩阵乘法有些相似——两个 $f$ 的第一项都与 $t$ 相关，后面的 $f$ 的第二项与 $d$ 的第一项相同，前面的 $f$ 的第二项与 $d$ 的第二项相同，就像一个 $(t - 1) \\times u$ 的矩阵在跟一个 $u \\times v$ 的矩阵做乘法，得到了一个 $t \\times u$ 的矩阵。于是，我们尝试将上述形式推广成一个更通用的结论。\n定义一种矩阵运算 $\\otimes$。若有 $A \\otimes B = C$，则 $A$ 的列数和 $B$ 的行数相同，$C$ 的行数与 $A$ 相同，列数与 $B$ 相同，且对矩阵 $C$ 中的每一个元素，都有：$C_{i, j} = \\max\\left\\lbrace A_{i, k} + B_{k, j} \\right\\rbrace$。根据取最大值 $\\max$ 运算的结合律，可以证明，该运算同样满足结合律。\n由于图中点的数量是固定的，所以 $d$ 可以视为一个行列数相等的矩阵，又由于 $\\otimes$ 运算具有结合律，因此 $d$ 可以通过对数复杂度的「矩阵快速幂」（但其中的「乘法」实际上是 $\\otimes$ 运算）进行迭代。在这样的观点下，我们可以将 $f_t$ 视为一个行向量，其每一个元素为 $f_{t, v}$，并得到一个非常神奇 ✨ 的转移方程：\n$$ f_t = f_0 \\otimes d^t $$\n下面用人话来解释一下这个方程的意思：\n根据我们刚才定义的运算所具有的性质，我们可以将同一类 $d$ 的，从初始状态 $t_0 = 0$ 到特定状态 $t$ 的贡献累积起来，但该操作是通过反复进行 $\\otimes$ 运算，用「矩阵快速幂」的形式将转移本身优化为 $\\mathcal{O}(\\log t)$ 复杂度，由此计算出 $d^t$ 来实现的。接下来，我们再通过一次 $\\otimes$ 运算将计算出来的贡献叠加到初始状态 $f_0$ 上，由此获得 $f_t$ 的状态。\n由于 $f$ 是行向量，其行数可视为 $1$，列数可视为元素数 $n$；而 $d$ 为 $n \\times n$ 矩阵，所以 $f_0 \\otimes d^t$ 所得到的结果的行数依然为 $1$，列数依然为 $n$，也就依然符合 $f$ 的行向量的形式。\n我们可以很容易地根据 $c$ 数组构建 $d$ 矩阵（没有边相连的地方，值为 $-\\infty$），那么现在的任务就是确定初始状态 $f_0$ 实际上应该是什么了。考虑 $f$ 的定义：$f_{t, v}$ 表示第 $t$ 天走到了城市 $v$ 时所能持有的最大愉悦值。由题目可知，主人公最初（第 $0$ 天）在城市 $1$，根据数据范围，第 $0$ 天不会有美食节（$1 \\leqslant t_i \\leqslant 10^9$），所以 $f_0$ 的元素中只有一个有值，即 $f_{0, 1} = c_1$，其他地方的值都是 $-\\infty$。\n矩阵优化的推广 还记得吗？上一小节里的推导都是基于 $w = 1$ 的前提的。而题目中 $w$ 的值可能在 $[1, 5]$ 之间变化，所以我们还需要思考如何将原来的结论应用到题目中来。当 $w = 1$ 时，我们对 $d$ 重复进行的 $\\otimes$ 运算，本质上是以 $w = 1$ 为单位在对贡献进行叠加。或者说，如果 $w \\in [1, 5]$，我们可以考虑将这些边权拆成 $1$ 到 $5$ 条 $w = 1$ 的边，在原有的这条边的起点和终点之间再加入 $w - 1$ 个点来承接这些新加的边，再将其贡献进行叠加。说白了就是，如果将此前我们推导时使用的 $d$ 写成 $d^1$，那么现在一条边权为 $w$ 的边的贡献就是 $d^w$，只是我们将指数 $w$ 掺到了整体的指数里进行计算。\n不过这样拆有个小问题。极端情况下，对于所有的 $m_{\\max} = 501$ 条边，每一条边的边权都为 $w_{\\max} = 5$，那么就需要新增 $\\left (w_{\\max} - 1 \\right ) m_{\\max} = 2004$ 个点。别忘了我们所需要用到的矩阵快速幂中，对一个具有 $n$ 点的图的邻接矩阵执行矩阵乘法本身也是具有 $\\mathcal{O}(n^3)$ 的复杂度的！假如我们的点数总共为 $\\left[ n_{\\max} + \\left( w_{\\max} - 1 \\right) m \\right] _ {\\max} = 2054$，那么光执行一次矩阵乘法就已经要超时了。有没有一种拆分的方法能够较小地影响实际的点数呢？\n我们考虑这样一种拆法：将每一个点拆成 $w$ 个点，这些点之间都用一条边权为 $0$ 的边连接。 对于每一条边 $(u, v, w)$，让 $u$ 拆出来的第 $w$ 个点 $u_w$ 与 $v$ 拆出来的第一个点 $v_1$ 之间用一条边权为 $w$ 的边相连。 这样做，首先只会用到 $w_{\\max}n = 5n$ 个点（由于每条边的 $w \\in [1, 5]$，$u$ 拆出来每个点上都可能有向其他点的连边，所以总共的点数其实就是钉死了的 $5n$），至少让矩阵乘法的复杂度降到了一个可以控制的范围。至于这样做为什么正确，其实就是利用了此前就已经明确的「无论指数是多少最后都会揉到一起去」的观点，并且无论指数是多少所经过的转移都恰好是 $w$ 步。\n这样，我们就成功将推得的结论应用到了 $w \\in [1, 5]$ 的情况。摆在我们面前的难题越来越少了！\n额外因素的考虑 别忘了还有「美食节」这一设定！回收伏笔啦！我们要想办法将美食节的贡献加入我们现有的体系中，该如何做呢？首先可以肯定的是，美食节显然没有办法直接加入我们的矩阵转移，因为美食节的时间地点和贡献大小都是不确定的。但是我们可以根据美食节的具体信息，在转移过程中修改对应时间、城市的贡献值。\n由于转移过程是根据 $t$ 从小到大进行的，所以我们可以将所有美食节 $\\left(t, x, y \\right)$ 根据 $t$ 进行排序，并在转移时，每次执行「矩阵快速幂」直到下一个美食节发生的时间 $t$，并将这个美食节 $\\left(t, x, y \\right)$ 的贡献 $y$ 添加到第 $t$ 天的城市 $x$ 上，然后继续通过「矩阵快速幂」从当前时间 $t$ 为起点进行转移。整个过程就像是乘坐游轮，在海上航行的过程就是执行矩阵快速幂来优化转移时间复杂度的过程，而每次靠岸、下船游玩则是在当前位置叠加美食节的贡献的、时间复杂度朴素的过程。\n最后一公里 不考虑美食节的情况下，拆点之后，「矩阵乘法」执行一次的复杂度为 $\\mathcal{O}(N^3)$，其中 $N = 5n$，所以「矩阵快速幂」的复杂度就为 $\\mathcal{O}(N^3 \\log T)$。但由于我们在考虑美食节之后，由于将原有的一整个长度为 $\\log T$ 的快速幂段分解成了最多 $201$ 个小段（$k_{\\max} = 200$），所以实际的复杂度为 $\\mathcal{O}\\left(N^3 \\sum\\log\\left(t_i - t_{i - 1}\\right)\\right)$。由于 $N_{\\max} = 250$，有 ${N ^ 3}_{\\max} = 1.5625 \\times 10^7$，再乘上一个 $200$ 很显然依然会超时。\n怎么办呢？DP 的过程已经想不出任何可以优化的地方了，此时我们考虑再次优化「矩阵快速幂」。我们知道，此前我们说「矩阵乘法」执行一次的复杂度为 $\\mathcal{O}(N^3)$，是因为是在对一个 $N \\times N$ 的邻接矩阵进行计算，其结果最终落脚到转移矩阵 $f_t$ 上，而 $f_t$ 是一个行向量。如果能够直接将操作在 $f_t$ 上面执行，不借用一整个邻接矩阵，我们或许就可以将原本 $\\mathcal{O}(N^3)$ 的复杂度降低到 $\\mathcal{O}(N^2)$，从而通过此题。\n由于 $\\otimes$ 运算具有结合律，所以对原本的 DP 转移式 $f_t = f_0 \\otimes d^t$，在考虑美食节后即 $f_{t_i} = f_{t_{i - 1}} \\otimes d^{t_i - t_{i - 1}}$。我们可以将快速幂 $d^{t_i - t_{i - 1}}$ 中分解出来的若干个 $d^{2^k}$ 直接 $\\otimes$ 乘到 $f_{t_{i - 1}}$ 上面！由于 $f_t$ 是行向量，相对于整个邻接矩阵来说少了一维，就可以像上面所说的实现 $\\mathcal{O}(N^2)$ 转移了！为此，我们其实只需要在得出整个邻接矩阵 $d$ 后，用 $\\mathcal{O}(N^3 \\log T)$ 的复杂度将所有满足 $2 ^ k \\leqslant T$ 的 $d^{2^k}$ 全部计算一遍就好了。计算出来之后，两次美食节之间就可以 $\\mathcal{O}\\left(N^2 \\sum\\log\\left(t_i - t_{i - 1}\\right)\\right)$ 复杂度转移，总共 $k$ 次，所以总复杂度就为：\n$$ \\mathcal{O} \\left (k \\log k + N^3 \\log T + k \\cdot N^2 \\sum\\log\\left(t_i - t_{i - 1}\\right) \\right ). $$\n代码 点击查看全部代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 #include \u0026lt;tuple\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; using LL = long long; using TUP = std::tuple\u0026lt;int, int, int\u0026gt;; const int MAX_N = 55; const int MAX_LG_T = 35; const int MAX_K = 2e2 + 5; const int MAX_N_S = MAX_N * 5; const LL LL_MIN = 0xC0C0C0C0C0C0C0C0; struct Matrix { LL data[MAX_N_S][MAX_N_S]; int row, col; void fill(const LL x) { for (int i = 1; i \u0026lt;= row; ++i) for (int j = 1; j \u0026lt;= col; ++j) data[i][j] = x; } Matrix operator*(const Matrix\u0026amp; B) const { Matrix C(row, B.col, LL_MIN); for (int i = 1; i \u0026lt;= row; ++i) for (int j = 1; j \u0026lt;= col; ++j) for (int k = 1; k \u0026lt;= B.col; ++k) C.data[i][k] = std::max(C.data[i][k], data[i][j] + B.data[j][k]); return C; } Matrix() {} Matrix(const int _r, const int _c, const LL x) : row(_r), col(_c) { fill(x); } }; int n, m, T, K; int c[MAX_N], logT; TUP fest[MAX_K]; Matrix G, pow2[MAX_LG_T], vec; void prep() { pow2[0] = G; for (int i = 1; i \u0026lt;= logT; ++i) pow2[i] = pow2[i - 1] * pow2[i - 1]; } void power(Matrix\u0026amp; A, int b) { if (b == 0) return; for (int i = 0; i \u0026lt;= logT; ++i) if ((b \u0026gt;\u0026gt; i) \u0026amp; 1) A = pow2[i] * A; } int main() { std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m \u0026gt;\u0026gt; T \u0026gt;\u0026gt; K; logT = std::__lg(T); // 计算 log(T) 的值 G = Matrix(n * 5, n * 5, LL_MIN); // 创建邻接矩阵并用负无穷填充 // 初始化每个点所拆成的五个点之间的连边 for (int i = 1; i \u0026lt;= n; ++i) for (int w = 1; w \u0026lt; 5; ++w) G.data[n * w + i][n * (w - 1) + i] = 0; for (int i = 1; i \u0026lt;= n; ++i) std::cin \u0026gt;\u0026gt; c[i]; for (int i = 1, u, v, w; i \u0026lt;= m; ++i) { std::cin \u0026gt;\u0026gt; u \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w; G.data[v][n * (w - 1) + u] = c[u]; // 按照边的信息把边连到拆开的点上 } for (int i = 1; i \u0026lt;= K; ++i) { auto\u0026amp; [t, x, y] = fest[i]; std::cin \u0026gt;\u0026gt; t \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; } prep(); // 二进制预处理邻接矩阵 std::sort(fest + 1, fest + K + 1); // 对美食节进行排序 Matrix vec(n * 5, 1, LL_MIN); // 创建 f 行向量 vec.data[1][1] = 0; // 初始化 // 分段转移 int current_time = 0; for (int i = 1; i \u0026lt;= K; ++i) { auto [time, city, joy] = fest[i]; power(vec, time - current_time); vec.data[city][1] += joy; current_time = time; } power(vec, T - current_time); // 输出答案 LL ans = vec.data[1][1] + c[1]; // 由于转移不考虑第一个城市，需要额外加上 std::cout \u0026lt;\u0026lt; (ans \u0026lt; 0 ? -1 : ans) \u0026lt;\u0026lt; std::endl; // 输出答案或者报告无解 return 0; } ","date":"2024-06-24T00:00:00+08:00","permalink":"https://eoin.blog/p/sol-luogu6772/","title":"「美食家」题解"},{"content":"我觉得，截至本文落笔之时，应该没有多少人会知道 OI Jumper 这个东西。这是我前两个月利用闲余时间开发的一款 OI 学习辅助工具。其功能非常简单，来到主页面，选择你需要的 OJ，输入题号或题目名称，按下 Enter 键或点击跳转，就可以自动打开一个浏览器窗口，快速访问你所指定的题目。虽然 OJ 跳题不是什么稀奇功能，当你需要大规模刷题的时候，如果题目分散在数个 OJ 中，而你又不想频繁打开多个主页的时候，OI Jumper 或许会成为一个有力的工具。如果正在阅读本文的你还没有体验过 OI Jumper，欢迎点击上面的链接跳转到它的页面并简单体验一下！ありがとうございます！！！\nOI Jumper 为开源项目，源码在对应的 GitHub 仓库上公开，网页由 Vercel 部署，首次访问可能需要加载一小段时间，浏览器缓存后加载时间就会变快许多。如果你对本项目有任何建议和意见，欢迎创建 issue 或拉取 PR 来做出贡献，谢谢！\n缘起 机缘巧合的一次，我在 Typora 官网发现了一套编辑器主题，名称为 Tailwind。好奇的我上网搜索了这个词语，并找到了 Tailwind CSS 这一宝藏框架。不需要亲自写 CSS，只需要在 HTML 代码里加入对应的 class name，就可以自动生成样式？我瞬间对它产生了好感，这种好感也随着此后不断碰到使用 Tailwind CSS 完成的优质网页而不断上升。尽管如此，由于常规学习生活所限，我一直没有找到什么学习它的理由或者应用它的地方。\n直到开始 OI 集训之后，我们的刷题量大幅上升，许多题目都分散在不同的 OJ 里，这使我这样一个半屏浏览器用户感到十分繁琐。为什么不做一个工具来帮我实现跳题呢？这便是 OI Jumper 立项的时候。然而，我退出开发转战 OI 已经有三年之久，网页更是有更长时间没有写过了。迅速拾起前端开发的知识，成为了项目从设想变为现实的一大瓶颈。我突然想到了在我愿望清单中滞留已久的 Tailwind CSS，说不定我能通过它简化一些开发流程。\n立项之时已经是 2024 年 4 月，各种免费 AI 工具早已充斥网络空间，Tailwind CSS 是一个前 AI 时代的产物，所以不如通过 AI 来在实践中快速地学习使用 Tailwind CSS 框架。这么想着，我打开了 Google Gemini 以及 Tailwind CSS 的官方文档，开始研读。\n开发 我并不是一个很喜欢读文档的人，所以在按照官网指示安装好环境并初始化之后，我就转向 AI 求助。两天的开发后，我就在 Gemini 的帮助下，利用此前学习的基础 CSS 知识结合着 Tailwind CSS 框架完成了最初的提交。部署完成的那一刻，我打开网页，感到心里充满了成就感。这时的网页已经实现了基本的题目跳转功能，支持深色模式的调整，且已经支持了洛谷、LibreOJ 和 Codeforces 三个 OJ。\n但这显然是不够的。接下来的半个月里，我陆陆续续对许多 OJ 添加了支持，直到我觉得这个网页应该添加点什么东西。很多时候，我在 OI 刷题时获得的都是题目的名称，如果需要找到对应题目，还是需要去到对应 OJ 的主页上点进搜索。于是，我决定给我的 OI Jumper 添加搜索功能。\n我第一次尝试实现时，原本只针对洛谷进行了开发，我所希望的成品是，页面向洛谷模拟一次搜索，获取到洛谷返回的包含搜索结果的 JSON 信息，然后呈现在 OI Jumper 的网页上。这看似一个很好的想法，但实际实现起来，却不是一般地困难重重。首先碰到的障碍是，浏览器的同源策略阻止了我读取洛谷的返回值。我此前从来没有碰到这种情况，所以立马通过搜索与询问 AI 进行了解，最终通过一个国内无法正常访问的 CORS 代理服务器临时地绕开了这个问题。接着，我发现，由于 CSS 功力有限，自己没有办法做出自己想要的呈现搜索结果的样式。在种种困难下，我的搜索功能停留在半成品阶段，静静地躺在了代码里。四天的思想斗争之后，我决定一切从简。与其从洛谷上爬取信息，不如直接跳转到洛谷的搜索页面去。于是，题目搜索的功能与题目跳转的功能回归到了同样的本质上，也方便了我对多个 OJ 的搜索功能添加支持。\n维护 从我最初学习网页开发的时候开始，就有一个东西在我的心头游荡：弹性框架 flexbox。直到我退出开发为止，我都没有学习到 flexbox 框架，还在使用最传统的 CSS Positioning 设置元素的排列方式。所以我想通过这个项目来感受一下 flexbox 给开发带来的便利。这里推荐一个讲 flexbox 的教程 (in English)：An Interactive Guide to Flexbox in CSS。\n下一个让我花了很大功夫的就是响应式设计。这是我很早就想做，但迟迟没做，却一直能感觉到我应该要去做的一件事情。虽然确实没有什么人会用移动设备卷题，但本着我对开发的热爱与对响应式设计的执念，我还是学习了它的实现方式。很惊喜地，Tailwind CSS 对响应式设计具有原生支持，所以极大程度降低了我的学习成本。我用一两天时间就写好了窄屏幕适配的代码，并激动地将其提交到了仓库里。\nLibreOJ 一直有一个很有意思的功能（当然许多其他网站也有），就是一言。我想在 OI Jumper 上也加入一言的功能。但向对方 API 发出的网络请求不出意外地再次被浏览器的同源策略以同样的方式拦截了。但一言的 API 服务器与洛谷的公开服务器有一个很大的区别，就是一言是支持 JSONP (JSON with Padding) 返回的！我前文所述的被同源策略拦截的时候搜索到了这种解决方式，虽然在支持洛谷搜索的时候发现洛谷的服务器并不支持，但成功在一言的开发上得到了实践。虽然 JSONP 并不是现代网络解决跨域资源共享的主流方式，但我很高兴自己能借此了解到浏览器与网络安全方面冰山一角的知识。\n直到下一次再有什么功能让我想要实现，或者有其他 OJ 需要支持，OI Jumper 将不再频繁更新。它的本质虽然是一个前端项目，但同时也能作为我回归前端开发的练手项目。我从这一项目的开发中学到了许多新知识，希望这些新知识能为我未来的项目开发奠定基础吧。\n回想 如果你已经看够了上面的流水账，那么这里可能会给你带来一些启发或者思考。\n就像 lxl 曾在洛谷动态为了批驳洛谷制度中认为 AIGC 是与算法竞赛无关这一部分而回复过的：\n闭关锁谷！等 AI 把算法竞赛淘汰掉，把 oier 吊打，就不是与算法竞赛无关了！！！\n这一天或许迟早要来。但放在算法竞赛这样一个当下的领域里，由于比拼的是人类的思维与智慧，所以人工智能能够扮演的角色至多就是在学习的时候提供辅助，洛谷的制度是可以理解的，毕竟洛谷是一个为人服务的网站。\n但有了这一次的经验，我觉得，抛开算法竞赛不谈，人工智能的介入并不意味着人类程序员一定要被替代。一方面，学习了无数资源的大模型可以在我们学习开发的过程中予以助力，使学习变得更有效率、更有成果，就像我在 Gemini 的辅助下利用 Tailwind CSS 和 JSONP 实现了 OI Jumper 项目一样；另一方面，即使是已经入行的程序员，人工智能扮演的角色也侧重于一个工具，比如帮忙 debug、帮忙优化代码实现等等，AI 相比于程式化的自动机更加智能，能够更有效率地处理一些程序开发中的琐事，但 AI 毕竟不是人脑，AI 的创造是基于过去的资源，而当我们需要面对创新时，只有人脑才能从过去的思维中挣脱，在创新的道路上越走越远。\n在算法竞赛中我们通过学习来锻炼自己的思维能力，这些思维能力的终产物是科学与技术的创新与进步。所以我觉得，人工智能只能为我们整理过去的知识，为现在的人类所用，让现在的人类有更多的时间来学习、来锻炼。人类的未来仍然是，也只能是由人类自己来铺就，而这项大工程如果要得以加速发展，就需要人工智能为我们省下那些面对过去的时间，更需要我们充分利用这些时间来为我们的现在与未来着想。\n","date":"2024-05-10T20:00:00+08:00","image":"https://eoin.blog/p/work-on-oi-jumper/banner_hub4dd82de076555203da25b7a1f054d03_54466_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://eoin.blog/p/work-on-oi-jumper/","title":"旧好重拾觅新知：简述 OI Jumper 的开发之路"},{"content":"这是笔者自己写的第一篇纯大模拟，因此本题的代码也是目前笔者写过最长的代码。\nHow to Code 依题意模拟即可。\n本题除了模拟代码外几乎没有任何思维含量，纯纯的码力题，只要审题足够仔细并且有足够的耐心，A 掉这题是并不困难的。如果写大模拟的经验不是很足的话，看到题目甚至会无从下手（比如我）。这时候就最好从头到尾把题目读一遍，或者多读几遍，然后尽量顺着程序的大致运行过程开始编码。下面就跟着程序运行的逻辑顺序来一步一步实现代码。首先，规定一下本文中某些变量类型的替代称谓（C++11 语法）：\n1 2 3 4 using f64 = double; using str = std::string; using MAP_SI = std::unordered_map\u0026lt;str, int\u0026gt;; using MAP_II = std::unordered_map\u0026lt;int, int\u0026gt;; 玩家信息输入 首先，几乎可以完全确定的是，题目给定的数据全部都是有用的。所以输入的所有东西都要存储起来。并且，对于本题中这样有关 “队伍” 与 “玩家” 这样阵营分明的设定，我们可以几乎肯定地使用类（结构体）将同一实体有关的数值封装起来。这样就获得了我们的 PLAYER 类，用于存储一个玩家的全部有关信息。由于题目有关玩家信息的输入是以玩家为单位的，所以我们在该类中定义一个成员函数 input() 用于处理单个玩家信息的输入。当然，我们也需要将题目中涉及到的其他没有被输入的玩家属性存储到这个类中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 int member_cnt[2]; struct PLAYER { int team_fr; // 归属队伍 int team_id; // 归属队伍内编号 int type; // 类型：0 = weak, 1 = average, 2 = strong int lvl; // 等级：1 ~ 100 f64 atk; // 基础攻击力 f64 def; // 基础防御力 int max_hp; // 体力上限 int act_skl; // 主动技能等级：0 ~ 5 int psv_skl; // 被动技能等级：0 ~ 5 int weapon_type; // 武器类型：0 = B, 1 = G, 2 = M f64 weapon_atk; // 武器攻击力 int hp; // 当前体力 bool status; // 状态：0 = dead, 1 = alive f64 skl_boost; // 技能加成 void input() { char player_type[10], weapon_type_t[4]; scanf(\u0026#34;%s Lv=%d maxhp=%d atk=%lf def=%lf skillLv=%d passivesklLv=%d %s weaponatk=%lf\\n\u0026#34;, player_type, \u0026amp;lvl, \u0026amp;max_hp, \u0026amp;atk, \u0026amp;def, \u0026amp;act_skl, \u0026amp;psv_skl, weapon_type_t, \u0026amp;weapon_atk); hp = max_hp; // 初始生命值为上限 status = true; // 初始角色未倒下 skl_boost = 1; // 初始技能加成为 1 type = PLAYER_TYPE[str(player_type)]; // 根据输入获取角色类型对应数字 weapon_type = WEAPON_TYPE[str(weapon_type_t)]; // 根据输入获取武器类型对应数字 } } team[2][7]; // ... int main() { scanf(\u0026#34;%d %d\\n\u0026#34;, \u0026amp;member_cnt[0], \u0026amp;member_cnt[1]); // 输入南队队员 for (int i = 1; i \u0026lt;= member_cnt[0]; ++i) { team[0][i].input(); team[0][i].team_fr = 0; team[0][i].team_id = i; } // 输入北队队员 for (int i = 1; i \u0026lt;= member_cnt[1]; ++i) { team[1][i].input(); team[1][i].team_fr = 1; team[1][i].team_id = i; } } 为了方便，我们将输入的字符串属性转换成数字，存储在一个常量哈希表中（详见文末代码部分）。\n获取当前回合的攻击方队员编号 通过阅读题面，我们可以知道，每一轮的攻击方（或技能施放方，以下我们将一回合内主动进行操作的一队统称为攻击方队伍）队伍是根据回合数确定的，攻击方队伍中的攻击者是根据队员编号进行选择的。\n为了追踪两队的攻击队员，我们定义数组 attacker[2]，分别存储两队当前的攻击队员编号。接着，为了根据题目含义确定每一回合的攻击队员，我们定义 get_attacker() 函数：\n1 2 3 4 5 6 7 8 9 10 11 int attacker[2]; /// @brief 计算每一回合攻击方队伍的攻击者 /// @param t 攻击方队伍的编号 void get_attacker(int t) { do { ++attacker[t]; if (attacker[t] \u0026gt; member_cnt[t]) attacker[t] = 1; } while (!team[t][attacker[t]].status); // 如果找到未倒下的角色就跳出循环 // 由于题目保证所有操作合法，所以不用担心死循环 } 为了确定每一个回合是哪一队进行攻击，我们在每次循环开头执行以下代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int round_cnt; int main() { // ... scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;round_cnt); for (int RND = 1; RND \u0026lt;= round_cnt; ++RND) { int t_a = (RND % 2) ^ 1; // 计算攻击方队伍 int t_b = (RND % 2); // 计算防御方队伍 // 获取攻击方队伍的当前攻击者 get_attacker(t_a); int active = attacker[t_a]; } } 计算伤害 伤害计算是施放攻击对敌人造成影响的重要要素。因此这一部分需要作为铺垫并率先考虑。根据题目中描述：\n「伤害」，即「体力值」减少的量，由「攻击强度」和受到「伤害」的人的「防御指数」决定。\n攻击强度是由攻击队员的各项数值确定的，最终扣血的数值通过受攻击队员的相关防御指数确定。可见，计算完的攻击强度是沟通施放伤害与承受伤害的桥梁。因此我们将计算完的攻击强度作为一个整体，对于单个队员实施扣血操作。为此，我们在 PLAYER 类中定义 deal_damage() 函数，用于根据当前角色受到攻击的强度来确定扣血的数值。同时，由于攻击强度的计算以及扣血数值的计算都需要用到以队伍为单位的攻击加成和防御加成，所以我们也需要定义这两个浮点型变量 atk_boost[2] 和 def_boost[2]。由于这两个数值最终是乘到计算中的，所以初始值需要赋值为 1。\n在扣血的时候，需要额外注意输出答案中的伤害大小是原始数值，但角色实际扣血是不能扣成负数的。其他扣血的地方也是同理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 f64 atk_boost[2] = {1, 1}; f64 def_boost[2] = {1, 1}; struct PLAYER { // ... void deal_damage(int, int, f64); } /// @brief 根据攻击强度对当前角色进行扣血 /// @param t_a 攻击方队伍的编号 /// @param act 攻击者在攻击方队伍内的编号 /// @param eff 攻击强度 void PLAYER::deal_damage(int t_a, int act, f64 eff) { if (!status) return; // 保险措施，如果已经倒下就不用考虑了 int dmg = eff / (def * def_boost[team_fr]); // 计算攻击产生扣血的有效值 hp -= dmg; // 扣血 // 如果扣血后角色生命值不高于 0，则该角色倒下 if (hp \u0026lt;= 0) { hp = 0; status = false; // 设定角色状态为倒下 } printf(\u0026#34;%s %d took %d damage from %s %d -\u0026gt; %d/%d\\n\u0026#34;, (team_fr ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), team_id, dmg, (t_a ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), act, hp, max_hp); } 攻击 由题面我们可以知道，攻击分四种：普通攻击和三种特殊攻击。阅读题面不难发现，这四种攻击中，只跟攻击队员相关的属性加成，以及跟受攻击队员的躲闪位置有关的方位加成，对于任何一种攻击都是相同的，所以我们先预处理出这一部分属性的加成。普通攻击和 B 特殊攻击比较简单，直接调用受攻击者的 deal_damage() 函数，并传入计算好的攻击强度值即可。G 攻击和 M 攻击属于 AoE 攻击，与受攻击队员的站位有关，因此我们先根据题目要求定义两个数组（我不知道为什么我要用一个哈希表）PLACE[] 和 INIT_INDEX[]，分别存储队员的站位顺序和每一个队员在队伍中的位置编号，这两个数组的信息是互为键值的。由此我们就可以获取 AoE 攻击中受攻击的队员了。接下来依题意模拟即可。\n需要注意的是，在 AoE 伤害中，虽然攻击强度中的方位加成是按照主要被攻击者的躲闪方位来计算的，但种族加成是按照受到攻击的实体本身的种族来计算的，所以这一部分需要单独考虑，这也是我把种族加成从预处理中孤立出来的一个主要因素。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 const int PLACE[6] = {5, 3, 1, 2, 4, 6}; MAP_II INIT_INDEX = {{1, 2}, {2, 3}, {3, 1}, {4, 4}, {5, 0}, {6, 5}}; /// @brief 实施普通攻击和特殊攻击 /// @param atk_p 攻击位置 /// @param ddg_p 躲闪位置 /// @param act 攻击者在攻击方队伍内的编号 /// @param trg 防御者在防御方队伍内的编号 /// @param t_a 攻击方队伍编号 /// @param t_b 防御方队伍编号 /// @param type 攻击类型，-1 为普通攻击，0~2 为对应的特殊攻击 void perform_attack(int atk_p, int ddg_p, int act, int trg, int t_a, int t_b, int type = -1) { // 由于 G 和 M 类型的种族加成对不同目标有不同的取值，所以预处理时不包含种族加成 f64 eff = team[t_a][act].atk * team[t_a][act].weapon_atk * team[t_a][act].skl_boost * atk_boost[t_a] * LOC_BOOST[(atk_p - ddg_p + 6) % 6]; // 普通攻击 if (type == -1) return team[t_b][trg].deal_damage(t_a, act, eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]); // B 型特殊攻击 if (type == 0) return team[t_b][trg].deal_damage(t_a, act, 1.25 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]); // 预处理 G 和 M 类型特殊 AoE 攻击的范围 int trg_l = -1, trg_r = -1; // 西边第一个未倒下的角色 for (int i = INIT_INDEX[trg] - 1; i \u0026gt;= 0; --i) if (team[t_b][PLACE[i]].status) { trg_l = PLACE[i]; break; } // 东边第一个未倒下的角色 for (int i = INIT_INDEX[trg] + 1; i \u0026lt; 6; ++i) if (team[t_b][PLACE[i]].status) { trg_r = PLACE[i]; break; } // G 型特殊攻击 if (type == 1) { int cand_cnt = (trg_l != -1) + (trg_r != -1) + 1; f64 mul = 1.35 / cand_cnt; team[t_b][trg].deal_damage(t_a, act, mul * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]); if (trg_l != -1) team[t_b][trg_l].deal_damage(t_a, act, mul * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_l].type]); if (trg_r != -1) team[t_b][trg_r].deal_damage(t_a, act, mul * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_r].type]); } // M 型特殊攻击 else if (type == 2) { team[t_b][trg].deal_damage(t_a, act, 1.15 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]); if (trg_l != -1) team[t_b][trg_l].deal_damage(t_a, act, 0.23 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_l].type]); if (trg_r != -1) team[t_b][trg_r].deal_damage(t_a, act, 0.23 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_r].type]); } } int main() { // ... for (int RND = 1; RND \u0026lt;= round_cnt; ++RND) { // ... char action_type[20]; int trg; scanf(\u0026#34;%s target=%d \u0026#34;, action_type, \u0026amp;trg); // 施放普通攻击 if (str(action_type) == \u0026#34;Basicattack\u0026#34;) { int atk_p, ddg_p; scanf(\u0026#34;atkpos=%d ddgpos=%d \\n\u0026#34;, \u0026amp;atk_p, \u0026amp;ddg_p); perform_attack(atk_p, ddg_p, active, trg, t_a, t_b); team[t_a][active].skl_boost = 1; // 施放攻击之后重置技能加成 } // 施放特殊攻击 else if (str(action_type) == \u0026#34;Specialattack\u0026#34;) { int atk_p, ddg_p; scanf(\u0026#34;atkpos=%d ddgpos=%d \\n\u0026#34;, \u0026amp;atk_p, \u0026amp;ddg_p); perform_attack(atk_p, ddg_p, active, trg, t_a, t_b, team[t_a][active].weapon_type); team[t_a][active].skl_boost = 1; // 施放攻击之后重置技能加成 } putchar(\u0026#39;\\n\u0026#39;); } } 释放主动技能 由于技能部分涉及到了很多常数，所以我们不如先把所有数值存起来。这个时候就体现出将字符串属性存储为整数的优越之处了。注意我的存法中，还包含了技能等级为 0 时的加成，虽然可能用不到，但还是存一下比较保险。\n1 2 3 4 5 6 7 8 9 10 11 const f64 ACT_SKL_MUL[3][6] = { {0.00, 0.10, 0.12, 0.15, 0.17, 0.20}, {0.00, 0.06, 0.07, 0.08, 0.09, 0.10}, {1.00, 2.10, 2.17, 2.24, 2.32, 2.40} }; const f64 PSV_SKL_MUL[3][6] = { {0.00, 0.013, 0.016, 0.019, 0.022, 0.025}, {0.00, 0.01, 0.02, 0.03, 0.04, 0.05}, {0.00, 0.01, 0.02, 0.03, 0.04, 0.05} }; 有关主动技能，有几点值得注意。\n第一是 Weak 类型的主动技能，技能释放的对象是本队成员，所以在传入参数的时候，目标队伍需要设定为本队。在回复生命的时候，需要额外注意输出答案中的回复量大小是原始数值，但角色实际回复生命是不能超过上限的。其他回复生命的地方也是同理。\n第二是 Average 类型的主动技能，会给对方施加 DoT 持续伤害并在技能释放者所在队伍的主动回合的回合末进行结算。由于 DoT 伤害一旦施加，就只与被施加的敌方队员有关了，所以我们在 PLAYER 类中对有关 DoT 伤害的信息进行存储，并定义函数 DOT()，在每一个生效回合末激活。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct PLAYER { // ... int dot_dmg; // 持续伤害大小 int dot_rounds; // 持续伤害层数 // ... void DOT(); } team[2][7]; /// @brief DoT，即 Damage over Time，处理当前角色受到的 Average 类型的持续伤害 void PLAYER::DOT() { if (!status) return; // 保险措施，如果已经倒下就不用考虑了 if (dot_rounds) { // 如果持续伤害层数不为 0 --dot_rounds, hp -= dot_dmg; // 则触发一次持续伤害并减一层层数 // 同上 if (hp \u0026lt;= 0) { hp = 0; status = false; } void input() { // ... dot_rounds = 0; // 初始持续伤害剩余层数为 0 dot_dmg = 0; // 初始持续伤害大小为 0 } printf(\u0026#34;%s %d took %d damage from skill -\u0026gt; %d/%d\\n\u0026#34;, (team_fr ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), team_id, dot_dmg, hp, max_hp); } } 那么接下来就可以写处理主动技能释放的函数了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 /// @brief 触发主动技能 /// @param act 释放技能者在释放技能方队伍内的编号 /// @param trg 被释放技能者在被释放技能方队伍内的编号 /// @param t_a 释放技能方队伍的编号 /// @param t_b 被释放技能队伍的编号 void activate_active_skill(int act, int trg, int t_a, int t_b) { // 获取技能类型名以便输出 str skl_type; if (team[t_a][act].type == 0) skl_type = \u0026#34;Weak\u0026#34;; else if (team[t_a][act].type == 1) skl_type = \u0026#34;Average\u0026#34;; else if (team[t_a][act].type == 2) skl_type = \u0026#34;Strong\u0026#34;; printf(\u0026#34;%s %d applied %s skill to %s %d\\n\u0026#34;, (t_a ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), act, skl_type.c_str(), (t_b ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), trg); // 对于 Weak 类型的主动技能 if (team[t_a][act].type == 0) { int tmp = team[t_b][trg].hp; int heal = ACT_SKL_MUL[0][team[t_a][act].act_skl] * team[t_b][trg].max_hp; // 计算回复量 team[t_b][trg].hp += heal; // 回复 if (team[t_b][trg].hp \u0026gt; team[t_b][trg].max_hp) // 如果回复后超过生命上限 team[t_b][trg].hp = team[t_b][trg].max_hp; // 则将生命值改为上限 if (tmp != team[t_b][trg].hp) // 如果生命值有所变动，就需要输出 printf(\u0026#34;%s %d recovered +%d hp -\u0026gt; %d/%d\\n\u0026#34;, (t_b ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), trg, heal, team[t_b][trg].hp, team[t_b][trg].max_hp); } // 对于 Average 类型的主动技能 else if (team[t_a][act].type == 1) { team[t_b][trg].dot_rounds = 3; // 设持续伤害持续 3 层 team[t_b][trg].dot_dmg = ACT_SKL_MUL[1][team[t_a][act].act_skl] * team[t_b][trg].max_hp; // 计算持续伤害大小 } // 对于 Strong 类型的主动技能 else if (team[t_a][act].type == 2) team[t_b][trg].skl_boost = ACT_SKL_MUL[2][team[t_a][act].act_skl]; // 更改角色的技能加成 } int main() { // ... for (int RND = 1; RND \u0026lt;= round_cnt; ++RND) { // ... // 施放主动技能 else if (str(action_type) == \u0026#34;Skill\u0026#34;) // 只有 Average 类型的主动技能是对敌方的 activate_active_skill(active, trg, t_a, (team[t_a][active].type == 1 ? t_b : t_a)); // 对防守方队伍中所有收到持续伤害的队员结算持续伤害（同队施放的持续伤害只在同队为攻击方的回合内生效） for (int i = 1; i \u0026lt;= member_cnt[t_b]; ++i) team[t_b][i].DOT(); putchar(\u0026#39;\\n\u0026#39;); } } 计算并施加被动技能 被动技能是本题主要的坑点之一，虽然题目已经说明，但还是很容易漏写。在角色倒下时，该角色给己方队伍贡献的被动技能数值需要重新计算。每回合开始时，还需要处理 Weak 类型的被动技能对己方队伍成员的生命值回复。因此我们写一个专门的函数 reapply_passive_skills()，在每次需要重新计算被动技能时，整体全部统计一遍。（反正数据范围小，复杂度再高也没什么问题。）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /// @brief 在每回合开始时及有角色倒下后重新计算被动伤害 /// @param t 默认为 -1，有角色倒下；如果输入为 0 或 1，则代表 Weak 类型的被动技能生效的团队 void reapply_passive_skills(int t = -1) { if (t != -1) { // 如果是开局，则需要使 Weak 类型的被动效果生效 f64 weak = 0; // 统计 Weak 被动叠加效果层数 for (int i = 1; i \u0026lt;= member_cnt[t]; ++i) if (team[t][i].status \u0026amp;\u0026amp; team[t][i].type == 0) // 对于当前队伍中所有还活着的 Weak 类型角色 weak += PSV_SKL_MUL[0][team[t][i].psv_skl]; // 根据其等级叠加效果加成 weak = std::min(weak, 0.05); // 考虑效果加成上限 for (int i = 1; i \u0026lt;= member_cnt[t]; ++i) { if (!team[t][i].status) continue; // 已经倒下的角色就不用考虑了 int tmp = team[t][i].hp; int heal = weak * team[t][i].max_hp; // 计算回复量 team[t][i].hp += heal; // 回复 if (team[t][i].hp \u0026gt; team[t][i].max_hp) // 如果回复后超过生命上限 team[t][i].hp = team[t][i].max_hp; // 则将生命值更改为上限 if (tmp != team[t][i].hp) // 如果生命值有所变动，就需要输出 printf(\u0026#34;%s %d recovered +%d hp -\u0026gt; %d/%d\\n\u0026#34;, (t ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), i, heal, team[t][i].hp, team[t][i].max_hp); } } // 对于其他两种类型，只需要在角色倒下后考虑被动技能分配情况即可 for (int t = 0; t \u0026lt; 2; ++t) { f64 average = 0, strong = 0; // 统计被动效果叠加层数 for (int i = 1; i \u0026lt;= member_cnt[t]; ++i) if (team[t][i].status) // 对于当前队伍中所有还活着的对应类型队员 if (team[t][i].type == 1) // 统计 Average 被动叠加层数 average += PSV_SKL_MUL[1][team[t][i].psv_skl]; else if (team[t][i].type == 2) // 统计 Strong 被动叠加层数 strong += PSV_SKL_MUL[2][team[t][i].psv_skl]; // 根据上限进行相应调整 average = std::min(average, 0.1); strong = std::min(strong, 0.1); // 增加对应的防御加成、攻击加成的值 def_boost[t] = average + 1; atk_boost[t] = strong + 1; } } 将这个函数添加到每回合开始时以及有角色倒下后即可。\n其他细节 比如回合末信息的输出和最后赢家的判定。这些小细节就请看下面的完整代码了。\nCode 以下代码建议使用 Visual Studio Code 或者其他功能较丰富的编辑器打开预览，因为我在部分函数上添加了 Doxygen 注释，以便增强代码可读性，即使已经没有什么可读性可言了。但一定不要复制粘贴提交，一定要自己写一遍！\n点击浏览全部代码（共 360 行，含注释） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 #include \u0026lt;cstdio\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;unordered_map\u0026gt; #define endl \u0026#39;\\n\u0026#39; using f64 = double; using str = std::string; using MAP_SI = std::unordered_map\u0026lt;str, int\u0026gt;; using MAP_II = std::unordered_map\u0026lt;int, int\u0026gt;; // 固定的加成数值 const f64 LOC_BOOST[6] = {1.25, 1.00, 0.75, 0.00, 0.75, 1.00}; const f64 TYPE_BOOST[3][3] = {{1.0, 0.9, 1.1}, {1.1, 1.0, 0.9}, {0.9, 1.1, 1.0}}; const int PLACE[6] = {5, 3, 1, 2, 4, 6}; const f64 ACT_SKL_MUL[3][6] = { {0.00, 0.10, 0.12, 0.15, 0.17, 0.20}, {0.00, 0.06, 0.07, 0.08, 0.09, 0.10}, {1.00, 2.10, 2.17, 2.24, 2.32, 2.40} }; const f64 PSV_SKL_MUL[3][6] = { {0.00, 0.013, 0.016, 0.019, 0.022, 0.025}, {0.00, 0.01, 0.02, 0.03, 0.04, 0.05}, {0.00, 0.01, 0.02, 0.03, 0.04, 0.05} }; f64 atk_boost[2] = {1, 1}; f64 def_boost[2] = {1, 1}; MAP_SI WEAPON_TYPE = {{\u0026#34;B\u0026#34;, 0}, {\u0026#34;G\u0026#34;, 1}, {\u0026#34;M\u0026#34;, 2}}; MAP_SI PLAYER_TYPE = {{\u0026#34;Weak\u0026#34;, 0}, {\u0026#34;Average\u0026#34;, 1}, {\u0026#34;Strong\u0026#34;, 2}}; MAP_II INIT_INDEX = {{1, 2}, {2, 3}, {3, 1}, {4, 4}, {5, 0}, {6, 5}}; int member_cnt[2]; int round_cnt; int attacker[2]; struct PLAYER { int team_fr; // 归属队伍 int team_id; // 归属队伍内编号 int type; // 类型：0 = weak, 1 = average, 2 = strong int lvl; // 等级：1 ~ 100 f64 atk; // 基础攻击力 f64 def; // 基础防御力 int max_hp; // 体力上限 int act_skl; // 主动技能等级：0 ~ 5 int psv_skl; // 被动技能等级：0 ~ 5 int weapon_type; // 武器类型：0 = B, 1 = G, 2 = M f64 weapon_atk; // 武器攻击力 int hp; // 当前体力 bool status; // 状态：0 = dead, 1 = alive f64 skl_boost; // 技能加成 int dot_dmg; // 持续伤害大小 int dot_rounds; // 持续伤害层数 void input() { char player_type[10], weapon_type_t[4]; scanf(\u0026#34;%s Lv=%d maxhp=%d atk=%lf def=%lf skillLv=%d passivesklLv=%d %s weaponatk=%lf\\n\u0026#34;, player_type, \u0026amp;lvl, \u0026amp;max_hp, \u0026amp;atk, \u0026amp;def, \u0026amp;act_skl, \u0026amp;psv_skl, weapon_type_t, \u0026amp;weapon_atk); hp = max_hp; // 初始生命值为上限 status = true; // 初始角色未倒下 skl_boost = 1; // 初始技能加成为 1 type = PLAYER_TYPE[str(player_type)]; // 根据输入获取角色类型对应数字 weapon_type = WEAPON_TYPE[str(weapon_type_t)]; // 根据输入获取武器类型对应数字 dot_rounds = 0; // 初始持续伤害剩余层数为 0 dot_dmg = 0; // 初始持续伤害大小为 0 } void deal_damage(int, int, f64); void DOT(); } team[2][7]; /// @brief 在每回合开始时及有角色倒下后重新计算被动伤害 /// @param t 默认为 -1，有角色倒下；如果输入为 0 或 1，则代表 Weak 类型的被动技能生效的团队 void reapply_passive_skills(int t = -1) { if (t != -1) { // 如果是开局，则需要使 Weak 类型的被动效果生效 f64 weak = 0; // 统计 Weak 被动叠加效果层数 for (int i = 1; i \u0026lt;= member_cnt[t]; ++i) if (team[t][i].status \u0026amp;\u0026amp; team[t][i].type == 0) // 对于当前队伍中所有还活着的 Weak 类型角色 weak += PSV_SKL_MUL[0][team[t][i].psv_skl]; // 根据其等级叠加效果加成 weak = std::min(weak, 0.05); // 考虑效果加成上限 for (int i = 1; i \u0026lt;= member_cnt[t]; ++i) { if (!team[t][i].status) continue; // 已经倒下的角色就不用考虑了 int tmp = team[t][i].hp; int heal = weak * team[t][i].max_hp; // 计算回复量 team[t][i].hp += heal; // 回复 if (team[t][i].hp \u0026gt; team[t][i].max_hp) // 如果回复后超过生命上限 team[t][i].hp = team[t][i].max_hp; // 则将生命值更改为上限 if (tmp != team[t][i].hp) // 如果生命值有所变动，就需要输出 printf(\u0026#34;%s %d recovered +%d hp -\u0026gt; %d/%d\\n\u0026#34;, (t ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), i, heal, team[t][i].hp, team[t][i].max_hp); } } // 对于其他两种类型，只需要在角色倒下后考虑被动技能分配情况即可 for (int t = 0; t \u0026lt; 2; ++t) { f64 average = 0, strong = 0; // 统计被动效果叠加层数 for (int i = 1; i \u0026lt;= member_cnt[t]; ++i) if (team[t][i].status) // 对于当前队伍中所有还活着的对应类型队员 if (team[t][i].type == 1) // 统计 Average 被动叠加层数 average += PSV_SKL_MUL[1][team[t][i].psv_skl]; else if (team[t][i].type == 2) // 统计 Strong 被动叠加层数 strong += PSV_SKL_MUL[2][team[t][i].psv_skl]; // 根据上限进行相应调整 average = std::min(average, 0.1); strong = std::min(strong, 0.1); // 增加对应的防御加成、攻击加成的值 def_boost[t] = average + 1; atk_boost[t] = strong + 1; } } /// @brief 根据攻击强度对当前角色进行扣血 /// @param t_a 攻击方队伍的编号 /// @param act 攻击者在攻击方队伍内的编号 /// @param eff 攻击强度 void PLAYER::deal_damage(int t_a, int act, f64 eff) { if (!status) return; // 保险措施，如果已经倒下就不用考虑了 int dmg = eff / (def * def_boost[team_fr]); // 计算攻击产生扣血的有效值 hp -= dmg; // 扣血 // 如果扣血后角色生命值不高于 0，则该角色倒下 if (hp \u0026lt;= 0) { hp = 0; status = false; // 设定角色状态为倒下 reapply_passive_skills(); // 重新考虑被动技能 } printf(\u0026#34;%s %d took %d damage from %s %d -\u0026gt; %d/%d\\n\u0026#34;, (team_fr ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), team_id, dmg, (t_a ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), act, hp, max_hp); } /// @brief DoT，即 Damage over Time，处理当前角色受到的 Average 类型的持续伤害 void PLAYER::DOT() { if (!status) return; // 保险措施，如果已经倒下就不用考虑了 if (dot_rounds) { // 如果持续伤害层数不为 0 --dot_rounds, hp -= dot_dmg; // 则触发一次持续伤害并减一层层数 // 同上 if (hp \u0026lt;= 0) { hp = 0; status = false; reapply_passive_skills(); } printf(\u0026#34;%s %d took %d damage from skill -\u0026gt; %d/%d\\n\u0026#34;, (team_fr ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), team_id, dot_dmg, hp, max_hp); } } /// @brief 计算每一回合攻击方队伍的攻击者 /// @param t 攻击方队伍的编号 void get_attacker(int t) { do { ++attacker[t]; if (attacker[t] \u0026gt; member_cnt[t]) attacker[t] = 1; } while (!team[t][attacker[t]].status); // 如果找到未倒下的角色就跳出循环 // 由于题目保证所有操作合法，所以不用担心死循环 } /// @brief 触发主动技能 /// @param act 释放技能者在释放技能方队伍内的编号 /// @param trg 被释放技能者在被释放技能方队伍内的编号 /// @param t_a 释放技能方队伍的编号 /// @param t_b 被释放技能队伍的编号 void activate_active_skill(int act, int trg, int t_a, int t_b) { // 获取技能类型名以便输出 str skl_type; if (team[t_a][act].type == 0) skl_type = \u0026#34;Weak\u0026#34;; else if (team[t_a][act].type == 1) skl_type = \u0026#34;Average\u0026#34;; else if (team[t_a][act].type == 2) skl_type = \u0026#34;Strong\u0026#34;; printf(\u0026#34;%s %d applied %s skill to %s %d\\n\u0026#34;, (t_a ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), act, skl_type.c_str(), (t_b ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), trg); // 对于 Weak 类型的主动技能 if (team[t_a][act].type == 0) { int tmp = team[t_b][trg].hp; int heal = ACT_SKL_MUL[0][team[t_a][act].act_skl] * team[t_b][trg].max_hp; // 计算回复量 team[t_b][trg].hp += heal; // 回复 if (team[t_b][trg].hp \u0026gt; team[t_b][trg].max_hp) // 如果回复后超过生命上限 team[t_b][trg].hp = team[t_b][trg].max_hp; // 则将生命值改为上限 if (tmp != team[t_b][trg].hp) // 如果生命值有所变动，就需要输出 printf(\u0026#34;%s %d recovered +%d hp -\u0026gt; %d/%d\\n\u0026#34;, (t_b ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;), trg, heal, team[t_b][trg].hp, team[t_b][trg].max_hp); } // 对于 Average 类型的主动技能 else if (team[t_a][act].type == 1) { team[t_b][trg].dot_rounds = 3; // 设持续伤害持续 3 层 team[t_b][trg].dot_dmg = ACT_SKL_MUL[1][team[t_a][act].act_skl] * team[t_b][trg].max_hp; // 计算持续伤害大小 } // 对于 Strong 类型的主动技能 else if (team[t_a][act].type == 2) team[t_b][trg].skl_boost = ACT_SKL_MUL[2][team[t_a][act].act_skl]; // 更改角色的技能加成 } /// @brief 实施普通攻击和特殊攻击 /// @param atk_p 攻击位置 /// @param ddg_p 躲闪位置 /// @param act 攻击者在攻击方队伍内的编号 /// @param trg 防御者在防御方队伍内的编号 /// @param t_a 攻击方队伍编号 /// @param t_b 防御方队伍编号 /// @param type 攻击类型，-1 为普通攻击，0~2 为对应的特殊攻击 void perform_attack(int atk_p, int ddg_p, int act, int trg, int t_a, int t_b, int type = -1) { // 由于 G 和 M 类型的种族加成对不同目标有不同的取值，所以预处理时不包含种族加成 f64 eff = team[t_a][act].atk * team[t_a][act].weapon_atk * team[t_a][act].skl_boost * atk_boost[t_a] * LOC_BOOST[(atk_p - ddg_p + 6) % 6]; // 普通攻击 if (type == -1) return team[t_b][trg].deal_damage(t_a, act, eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]); // B 型特殊攻击 if (type == 0) return team[t_b][trg].deal_damage(t_a, act, 1.25 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]); // 预处理 G 和 M 类型特殊 AoE 攻击的范围 int trg_l = -1, trg_r = -1; // 西边第一个未倒下的角色 for (int i = INIT_INDEX[trg] - 1; i \u0026gt;= 0; --i) if (team[t_b][PLACE[i]].status) { trg_l = PLACE[i]; break; } // 东边第一个未倒下的角色 for (int i = INIT_INDEX[trg] + 1; i \u0026lt; 6; ++i) if (team[t_b][PLACE[i]].status) { trg_r = PLACE[i]; break; } // G 型特殊攻击 if (type == 1) { int cand_cnt = (trg_l != -1) + (trg_r != -1) + 1; f64 mul = 1.35 / cand_cnt; team[t_b][trg].deal_damage(t_a, act, mul * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]); if (trg_l != -1) team[t_b][trg_l].deal_damage(t_a, act, mul * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_l].type]); if (trg_r != -1) team[t_b][trg_r].deal_damage(t_a, act, mul * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_r].type]); } // M 型特殊攻击 else if (type == 2) { team[t_b][trg].deal_damage(t_a, act, 1.15 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg].type]); if (trg_l != -1) team[t_b][trg_l].deal_damage(t_a, act, 0.23 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_l].type]); if (trg_r != -1) team[t_b][trg_r].deal_damage(t_a, act, 0.23 * eff * TYPE_BOOST[team[t_a][act].type][team[t_b][trg_r].type]); } } int main() { scanf(\u0026#34;%d %d\\n\u0026#34;, \u0026amp;member_cnt[0], \u0026amp;member_cnt[1]); // 输入南队队员 for (int i = 1; i \u0026lt;= member_cnt[0]; ++i) { team[0][i].input(); team[0][i].team_fr = 0; team[0][i].team_id = i; } // 输入北队队员 for (int i = 1; i \u0026lt;= member_cnt[1]; ++i) { team[1][i].input(); team[1][i].team_fr = 1; team[1][i].team_id = i; } scanf(\u0026#34;%d\\n\u0026#34;, \u0026amp;round_cnt); for (int RND = 1; RND \u0026lt;= round_cnt; ++RND) { int t_a = (RND % 2) ^ 1; // 计算攻击方队伍 int t_b = (RND % 2); // 计算防御方队伍 // 对攻击方队伍施放 Weak 类型被动技能 reapply_passive_skills(t_a); // 获取攻击方队伍的当前攻击者 get_attacker(t_a); int active = attacker[t_a]; char action_type[20]; int trg; scanf(\u0026#34;%s target=%d \u0026#34;, action_type, \u0026amp;trg); // 施放普通攻击 if (str(action_type) == \u0026#34;Basicattack\u0026#34;) { int atk_p, ddg_p; scanf(\u0026#34;atkpos=%d ddgpos=%d \\n\u0026#34;, \u0026amp;atk_p, \u0026amp;ddg_p); perform_attack(atk_p, ddg_p, active, trg, t_a, t_b); team[t_a][active].skl_boost = 1; // 施放攻击之后重置技能加成 } // 施放特殊攻击 else if (str(action_type) == \u0026#34;Specialattack\u0026#34;) { int atk_p, ddg_p; scanf(\u0026#34;atkpos=%d ddgpos=%d \\n\u0026#34;, \u0026amp;atk_p, \u0026amp;ddg_p); perform_attack(atk_p, ddg_p, active, trg, t_a, t_b, team[t_a][active].weapon_type); team[t_a][active].skl_boost = 1; // 施放攻击之后重置技能加成 } // 施放主动技能 else if (str(action_type) == \u0026#34;Skill\u0026#34;) // 只有 Average 类型的主动技能是对敌方的 activate_active_skill(active, trg, t_a, (team[t_a][active].type == 1 ? t_b : t_a)); // 对防守方队伍中所有收到持续伤害的队员结算持续伤害（同队施放的持续伤害只在同队为攻击方的回合内生效） for (int i = 1; i \u0026lt;= member_cnt[t_b]; ++i) team[t_b][i].DOT(); // 先输出北队，再输出南队 for (int t = 1; ~t; --t) { printf(\u0026#34;%s: \u0026#34;, t ? \u0026#34;North\u0026#34; : \u0026#34;South\u0026#34;); for (int i = 0; i \u0026lt; 6; i++) if (PLACE[i] \u0026lt;= member_cnt[t]) // 如果队伍不足 6 人就不输出对应位置的生命值 printf(\u0026#34;%d/%d \u0026#34;, team[t][PLACE[i]].hp, team[t][PLACE[i]].max_hp); putchar(\u0026#39;\\n\u0026#39;); } putchar(\u0026#39;\\n\u0026#39;); } // 统计是否有队伍获胜 int alive_cnt[2] = {0, 0}; for (int t = 0; t \u0026lt; 2; ++t) for (int i = 1; i \u0026lt;= member_cnt[t]; ++i) if (team[t][i].status || team[t][i].hp) ++alive_cnt[t]; if (!alive_cnt[0]) puts(\u0026#34;Team North won.\u0026#34;); else if (!alive_cnt[1]) puts(\u0026#34;Team South won.\u0026#34;); return fflush(stdout), 0; } Tips 写这道题让我获得了许多写模拟的心得，下面简单说几条我觉得比较重要的。\n对于纯模拟题，一定要保证关键信息的可获取性。简单来说，在任何环境下，你都一定要保留至少一种查询到你所需要的信息的方式。它决定了我们需要维护什么东西。 保证代码可读。平时写 OI 题那种只有一个字母的变量名尽量少出现，多写注释，要让自己时刻清楚自己在写什么代码、实现什么功能，不被大量的信息冲昏头脑。 善用 Ctrl/Cmd + F 查找。像本题这种，同样一种属性可能在很多地方被影响或者影响其他数值的情况，最好用浏览器或 PDF 阅读器的查找功能找到某一个属性在题目表述中所有出现的地方，确保自己考虑周全了。 Epilogue 感谢你看到这里。这份代码或许不是最为简洁、最有效率的一份代码，但我依然希望你在完成这道题、阅读这篇题解的过程中有所收获。毕竟，正如出题人提供的的大样例成为我 AC 这道题的道路上一份有力的援助一样，写出这道题也一定是我们锻炼自己编码能力和调试能力、最终成为一名优秀的程序员的路途中一次十分有价值的经历吧。与你共勉。\n","date":"2024-05-10T00:00:05+08:00","permalink":"https://eoin.blog/p/sol-luogu9381/","title":"「那些脑海里最珍贵的」题解"},{"content":"本篇杂题选解包含三道题的文字讲解，题目难度从绿到蓝。主要涉及了一些区间类问题与倍增、双指针等算法的结合运用。\n区间 出处：NOI 2016 题面与评测地址：洛谷 P1712 \u0026amp; LibreOJ #2086 参考题解：by 宝硕 先从题目最浅层的问题开始分析。如何从所有合法方案中获取到最小的花费？根据题目中的定义，我们希望找到所选中的区间长度极差最小的情况，可以通过双指针来维护。\n将所有区间按照长度从小到大排序，然后以最短区间作为左右指针的起始点开始枚举，双指针维护的是当前被选中的区间的范围左右界下标。每次枚举到一个区间，将其设为选中状态，即在数轴上将该区间内的所有位置的覆盖层数叠加一层。如果当前整个数轴上存在一个整数 $x$ 被覆盖了 $m$ 次，那么就已经有了一个可行解（左右指针之间区间的个数），此时我们利用该可行解尝试更新最优解，然后删除位于左指针的区间给数轴上叠加的一层，即令其被取消选中，并向右移动左指针，直到不存在被覆盖 $m$ 次的数，由此尝试缩小极差、取得更优答案；如果整个数轴上不存在任何整数被覆盖了 $m$ 次，那么向右移动右指针，尝试取得下一个可行解。由于双指针算法在有序序列上的正确性，一定能找到所有合法方案中的最优解。\n根据上面的分析，我们发现过程中需要对数轴上元素进行区间修改。同时由于数轴的范围在 $10^9$ 级别，所以我们采用离散化权值线段树的方式来维护我们需要的内容。离散化不再赘述。对于线段树，具体地，我们根据离散化后的数轴上每一个单点被覆盖的次数，维护区间内被覆盖次数的最大值。当整个数轴上被覆盖次数最大值超过或等于 $m$ 的时候，我们根据前文提到的操作，利用可行解更新最优解。\n在代码实现上，需要注意的地方包括：由于线段总数最大为 $5 \\times 10^5$，那么离散化数组需要存储的端点数量最大就会达到 $10^6$，所以线段树需要开 $2 \\times 4 n = 8 n$ 的空间；由于只需要对整个数轴范围上被覆盖次数的最大值进行查询，所以没有必要单独写一个查询函数，直接访问线段树的根节点即可。\n点击查看全部代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 #include \u0026lt;limits\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #define endl \u0026#39;\\n\u0026#39; using std::cin; using std::cout; using std::vector; using PII = std::pair\u0026lt;int, int\u0026gt;; const int MAX_N = 5e5 + 5; int N, M; PII seg[MAX_N]; vector\u0026lt;int\u0026gt; disc; struct SegTree { struct Node { int l, r; int tag, max; } node[MAX_N \u0026lt;\u0026lt; 3]; void pushup(int u) { node[u].max = std::max(node[u \u0026lt;\u0026lt; 1].max, node[u \u0026lt;\u0026lt; 1 | 1].max); } void pushdown(int u) { if (node[u].tag) { node[u \u0026lt;\u0026lt; 1].tag += node[u].tag; node[u \u0026lt;\u0026lt; 1].max += node[u].tag; node[u \u0026lt;\u0026lt; 1 | 1].tag += node[u].tag; node[u \u0026lt;\u0026lt; 1 | 1].max += node[u].tag; node[u].tag = 0; } } void build(int l, int r, int u = 1) { node[u] = {l, r, 0, 0}; if (l == r) return; int mid = (l + r) \u0026gt;\u0026gt; 1; build(l, mid, u \u0026lt;\u0026lt; 1); build(mid + 1, r, u \u0026lt;\u0026lt; 1 | 1); } void update(int l, int r, int x = 1, int u = 1) { if (node[u].l \u0026gt;= l \u0026amp;\u0026amp; node[u].r \u0026lt;= r) { node[u].tag += x; node[u].max += x; return; } pushdown(u); int mid = (node[u].l + node[u].r) \u0026gt;\u0026gt; 1; if (l \u0026lt;= mid) update(l, r, x, u \u0026lt;\u0026lt; 1); if (r \u0026gt; mid) update(l, r, x, u \u0026lt;\u0026lt; 1 | 1); pushup(u); } } SGT; int main() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M; for (int i = 1; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; seg[i].first \u0026gt;\u0026gt; seg[i].second; disc.push_back(seg[i].first); disc.push_back(seg[i].second); } auto cmp = [\u0026amp;](PII x, PII y) { return x.second - x.first \u0026lt; y.second - y.first; }; std::sort(seg + 1, seg + N + 1, cmp); std::sort(disc.begin(), disc.end()); disc.erase(std::unique(disc.begin(), disc.end()), disc.end()); for (int i = 1; i \u0026lt;= N; i++) { seg[i].first = std::lower_bound(disc.begin(), disc.end(), seg[i].first) - disc.begin() + 1; seg[i].second = std::lower_bound(disc.begin(), disc.end(), seg[i].second) - disc.begin() + 1; } SGT.build(1, disc.size()); int ans = std::numeric_limits\u0026lt;int\u0026gt;::max(); auto len = [\u0026amp;](int x) { return disc[seg[x].second - 1] - disc[seg[x].first - 1]; }; for (int i = 1, l = 1; i \u0026lt;= N; i++) { SGT.update(seg[i].first, seg[i].second); while (SGT.node[1].max \u0026gt;= M) { ans = std::min(ans, len(i) - len(l)); SGT.update(seg[l].first, seg[l].second, -1); l++; } } if (ans == std::numeric_limits\u0026lt;int\u0026gt;::max()) ans = -1; cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return fflush(stdout), 0; } Opportunity Cost 出处：ICPC 2020 World Finals 官方题面：英语 中文题面及评测地址：LibreOJ #6796 \u0026amp; 洛谷 P8134 根据题目所给的式子，我们不难发现：对于一部手机 $\\left( x, y, z \\right)$，这三种参数最终被计入这部手机的 opportunity cost，只有两种情况。一则该项参数在所有同种参数中最大，则该参数计入值为 $0$；二则该项参数在所有同种参数中并非最大，则该参数计入值为 $x_i - x$，$y_i - y$ 或 $z_i - z$。第一种情况显然是最理想的，但它同时也对我们计算 opportunity cost 没有任何贡献，所以我们只考虑这三项参数出现第二种情况时的处理方式。我们假设该手机的三种参数都出现了第二种情况，则这部手机的 opportunity cost 为：\n$$ \\begin{aligned} f(x, y, z) \u0026amp;= \\max_{1 \\leqslant i \\leqslant n} \\left( x_i - x + y_i - y + z_i - z \\right) \\newline \u0026amp;= \\max_{1 \\leqslant i \\leqslant n} \\left( x_i + y_i + z_i - x - y - z \\right) \\newline \u0026amp;= \\max_{1 \\leqslant i \\leqslant n} \\left( x_i + y_i + z_i \\right) - x - y - z \\end{aligned} $$\n第二行到第三行的转化是因为 $x, y, z$ 对于我们当前所求的这部手机来说都是定值。因此，我们需要维护的就只有求所有手机三种参数之和的最大值这一部分内容了。当然，上面列举的只是当三种参数都出现第二种情况的时候的处理方式。而对于第一种情况，由于计入值为 $0$，我们可以直接从上面的表达式里删掉对应的项，并维护在删掉对应种类参数的情况下所有手机的剩下的参数之和的最大值即可。由于这三种参数都可能独立出现第一种情况和第二种情况，所以最终最多会有 $2^3 = 8$ 种状态的最大值需要维护。每一种状态维护最大值只需要 $\\mathcal{O}\\left(n\\right)$ 的复杂度，所以可以直接通过暴力枚举解决。\n在预处理完所需的最大值后，接下来就是根据我们推出的公式以及求得的最大值，对每一部手机的 opportunity cost 进行计算。在上面的暴力枚举过程中，会出现一种情况，即某一手机的某种参数并非同种参数中的最大值，但在预处理时却被统计成 $0$ 的情况。所以我们在计算时也需要把 $8$ 种情况全部跑一遍，求这 $8$ 种情况的三种参数计入值之和的最大值。同时，由于当某一手机的某种参数 $p$ 为同种参数 $p_i$ 中的最大值时，一定有 $\\forall 1 \\leqslant i \\leqslant n,~ p_i - p \\leqslant 0$，所以在我们统计最大值时，其中 $\u0026lt; 0$ 的情况会被其他情况中的 $0$ 覆盖掉，所以这样做不会影响答案的正确性。\n代码实现上，注意三种参数之和最高能达到 $3 \\times 10^9$，所以需要使用 unsigned int 或 long long 等类型存储。\n点击查看全部代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include \u0026lt;limits\u0026gt; #include \u0026lt;iostream\u0026gt; #define endl \u0026#39;\\n\u0026#39; using std::cin; using std::cout; using u32 = unsigned int; const int MAX_N = 2e5 + 5; const int CASES = 1 \u0026lt;\u0026lt; 3; u32 N, x[MAX_N], y[MAX_N], z[MAX_N]; u32 max[CASES]; void prep() { for (u32 i = 0; i \u0026lt; CASES; i++) for (u32 j = 1, sum; j \u0026lt;= N; j++) { sum = (i \u0026gt;\u0026gt; 0 \u0026amp; 1) ? x[j] : 0; sum += (i \u0026gt;\u0026gt; 1 \u0026amp; 1) ? y[j] : 0; sum += (i \u0026gt;\u0026gt; 2 \u0026amp; 1) ? z[j] : 0; max[i] = std::max(max[i], sum); } } int main() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; N; for (u32 i = 1; i \u0026lt;= N; i++) cin \u0026gt;\u0026gt; x[i] \u0026gt;\u0026gt; y[i] \u0026gt;\u0026gt; z[i]; prep(); u32 ans1 = std::numeric_limits\u0026lt;u32\u0026gt;::max(), ans2 = 0; for (u32 i = 1, cost; i \u0026lt;= N; i++) { cost = 0; for (u32 j = 0, sum; j \u0026lt; CASES; j++) { sum = (j \u0026gt;\u0026gt; 0 \u0026amp; 1) ? x[i] : 0; sum += (j \u0026gt;\u0026gt; 1 \u0026amp; 1) ? y[i] : 0; sum += (j \u0026gt;\u0026gt; 2 \u0026amp; 1) ? z[i] : 0; cost = std::max(cost, max[j] - sum); } if (cost \u0026lt; ans1) ans1 = cost, ans2 = i; } cout \u0026lt;\u0026lt; ans1 \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; ans2 \u0026lt;\u0026lt; endl; return fflush(stdout), 0; } Running Away From the Barn 出处：USACO 2012 December Contest (Gold) 官方题面及评测地址：英语 中文题面及评测地址：洛谷 P3066 看到数据范围，可以看到 $p_i \u0026lt; i$。也就是说，$\\forall v \\in T_u, u \u0026gt; v$。因此，树上任何一个节点到达其任意一个祖先的路径上所有节点的编号一定都是单调递减的。因此，我们可以倒序地维护一个差分数组，对于每一个节点，以其为起始端点，将其向根方向移动 $T$ 的距离内所能到达最远的节点作为结束端点，利用差分对起始端点到结束端点的路径上所有的节点被覆盖的次数进行区间 $+1$，即可得到每个节点最终被覆盖的总次数，即为答案。\n这里的差分方法和普通的差分不同的地方在于：\n差分维护的区间在数组中并不是连续的，普通数组中元素之间通过固定的下标之差来维护的差分，在本题中需要通过树上节点之间的亲子关系来维护； 执行区间 $+1$ 操作时，差分 $+1$ 的点其实是编号较大的节点，$-1$ 的点反而是编号较小的节点。这一点其实很好理解。我们希望，被差分修改的位置正好代表从某个节点到达其特定祖先的路径上的所有节点，因此我们需要从子节点出发朝根节点的方向进行修改。如果从祖先的位置开始修改，那么最终，以祖先为根节点的子树里，只有路径上的节点的差分最后 $-1$ 了，其他与这条路径无关的节点都会被额外 $+1$，导致最终结果错误。 由于数据范围为 $2 \\times 10^5$，我们可以通过树上倍增来维护每个节点的各级祖先，由此在 $\\mathcal{O} \\left(\\log N\\right)$ 复杂度内找到查分的两个端点。所以这种解法的整体复杂度为 $\\mathcal{O} \\left(N \\log N\\right)$，可以通过本题。\n点击查看全部代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #include \u0026lt;iostream\u0026gt; #define endl \u0026#39;\\n\u0026#39; using std::cin; using std::cout; using i64 = long long; const int MAX_N = 2e5 + 5; int N, fa[MAX_N][20]; i64 T, depth[MAX_N], d[MAX_N]; int main() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; T; d[1] = 1; for (int i = 2, p; i \u0026lt;= N; ++i) { i64 w; cin \u0026gt;\u0026gt; p \u0026gt;\u0026gt; w; fa[i][0] = p; depth[i] = depth[p] + w; for (int j = 1; j \u0026lt;= 18; ++j) fa[i][j] = fa[fa[i][j - 1]][j - 1]; int u = i; for (int j = 18; ~j; --j) if (depth[i] - depth[fa[u][j]] \u0026lt;= T) u = fa[u][j]; ++d[i], --d[fa[u][0]]; } for (int i = N; i; --i) d[fa[i][0]] += d[i]; for (int i = 1; i \u0026lt;= N; ++i) cout \u0026lt;\u0026lt; d[i] \u0026lt;\u0026lt; endl; return fflush(stdout), 0; } ","date":"2024-05-10T00:00:04+08:00","permalink":"https://eoin.blog/p/misc-solutions-2/","title":"杂题选解（二）"},{"content":"本篇杂题选解包含四道题的文字讲解，题目难度从绿到紫。主要涉及了分治思想结合数据结构的应用，也涉及到一些图论方面的问题。\nFoehn Phenomena 出处：JOI 2017 Final 官方题面：日语 \u0026amp; 英语 评测地址：AtCoder \u0026amp; LibreOJ #2332 由于题目的设置与序列中相邻两个元素之间的差值有关，并且之后给出的每一次操作都需要进行一次区间加，就很容易想到通过差分维护。考虑到每次修改都是对区间的海拔进行整体升高或降低，故每次修改对差分数组的影响只会体现在左右两个端点上。也就是说，每次修改某个区间的海拔时，由于区间内部的相对地形不变，所以区间内部对海风温度产生影响的大小也是不变的，因而我们只需要根据两个端点处的差值对答案进行修改即可。\n具体地，我们先确定初始情况下各相邻两个元素之间的差值，并且依此维护海风到达 $N$ 时最终的温度，然后再根据每次修改的左右端点进行操作。对于两个端点，我们先减去根据此前的差值确定的风的温度，然后将修改值更新到该位置对应的差分数组上，最后根据新的差值重新计算风的温度。\n在代码实现上有两个小细节：\n如果海拔从低到高，那么温度下降，此时的差值为正数，但对差分数组的增量应该是一个负数，也就是差值与 $S$ 的积的相反数；如果海拔从高到低，那么温度上升，此时的差值为负数，但对差分数组的增量应该是一个正数，也就是差值与 $T$ 的积的相反数； 如果修改的右端点是 $N$，那么右端点处的差分以及答案就不需要更新了，因为此时右端点的修改影响不到任何差值。 点击查看全部代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #include \u0026lt;iostream\u0026gt; #define endl \u0026#39;\\n\u0026#39; using std::cin; using std::cout; using i64 = long long; const int MAX_N = 2e5 + 5; int N, Q, S, T; i64 delta[MAX_N]; i64 alter(i64 i) { if (delta[i] \u0026gt; 0) return -delta[i] * S; return -delta[i] * T; } int main() { std::ios::sync_with_stdio(false); cin.tie(nullptr); int last = 0; i64 ans = 0; cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; Q \u0026gt;\u0026gt; S \u0026gt;\u0026gt; T \u0026gt;\u0026gt; last; for (int i = 1, curr; i \u0026lt;= N; i++) { cin \u0026gt;\u0026gt; curr; delta[i] = curr - last; ans += alter(i); last = curr; } while (Q--) { int L, R, X; cin \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R \u0026gt;\u0026gt; X; ans -= alter(L); delta[L] += X; ans += alter(L); if (R \u0026lt; N) { ans -= alter(R + 1); delta[R + 1] -= X; ans += alter(R + 1); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; } return fflush(stdout), 0; } 暑假时在做什么？有没有空？可以来学物理吗？ 出处：LibreOJ 官方题面及评测地址：LibreOJ #6490 参考题解：by ImALAS 这道题的朴素做法其实非常好想。对于每一个 $a_i$，暴力枚举区间长度，然后枚举区间端点，求区间和，取最大值即可。如果加上一个前缀和优化，那么朴素做法的复杂度将达到 $\\mathcal{O} \\left( n ^ 3 \\right)$。\n考虑如何优化。我们知道，对于一段子区间 $\\left[ L, R \\right]$，它的区间和可以通过前缀和得到，即 $\\sum _ {i = L} ^ {R} = \\text{pre} _ R - \\text{pre} _ {L - 1}$。在本题中，当 $L, R$ 并非确定值，而是各自在一个确定的取值范围内浮动的时候，想要找到最大的子区间和，就需要找到最小的 $\\text{pre} _ {L - 1}$ 以及最大的 $\\text{pre} _ R$。因此我们可以考虑使用数据结构维护区间最大值和最小值，而所需要维护的序列便是前缀和数组。本题由于时限只有 400 毫秒、没有对数组元素的修改并且包含很多的查询操作，所以使用 ST 表来维护。\n不过，这只是把对单个 $a_i$ 求答案的问题解决了，复杂度还不足以拿满分。为此，我们需要想想如何一次性求出对于所有元素的答案。考虑分治。对于每一层的问题规模，我们先递归求出只考虑左半边时，左半边元素的最优答案，以及只考虑右半边时右半边元素的最优答案，然后考虑左右两边合并时对规模内的所有元素的答案造成的影响。\n具体来说，在合并考虑左右两边的影响时，以左半边为例，我们先顺序遍历一遍左半边 $\\left[ l, \\text{mid} \\right]$ 的所有下标 $i$，用一个 $p$ 变量存储最优答案，每次查询用 ST 表查询\n$$ \\left( \\max\\left\\lbrace i + l - 1, \\text{mid} + 1\\right\\rbrace , \\min\\left\\lbrace i + r - 1, R\\right\\rbrace \\right) $$\n区间内的最大前缀和 $\\text{pre} _ {\\max}$（其中 $l, r$ 为区间长度的取值范围，$R$ 为问题规模的上界，$\\text{mid}$ 为问题规模的中点），然后更新 $p = \\max\\left\\lbrace p, \\text{pre}_{\\max}\\right\\rbrace$，$f_i = \\max\\left\\lbrace f_i, p\\right\\rbrace$。以上是合并时考虑左半边的过程。对于右半边，需要倒序遍历并使用同样的方法进行维护，取得最优答案。\n还是以左半边为例，这样做的正确性在于：\n$p$ 的范围一定会覆盖当前遍历到的位置，因为查询区间的起点在右半边，所以无论如何查询，最终结果一定覆盖了当前位置直到左半边的右端点在内的所有下标。 如果左边的某个元素在规模扩展到右边界后答案并不优于此前在分治左半边过程中确定的答案，那么 $f_i$ 不会被更新；如果扩展之后答案更优，那么 $f_i$ 会被更新为更优的答案。 代码实现上，需要关注的地方有：\n记得开 long long； 根据以上方法使用 ST 表进行查询时，以左半边为例，当左边界取 $\\text{mid} + 1$ 且右边界取 $i + r - 1$ 的时候，可能出现左边界大于右边界的情况。这种情况表示区间长度取不到右半边里，故返回极值来避免统计这种情况。 点击查看全部代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 #include \u0026lt;climits\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #define endl \u0026#39;\\n\u0026#39; using namespace std; using i64 = long long; const int N = 1e5 + 5; const int M = 20; struct SparseTable { i64 mx[N][M]; i64 mn[N][M]; int log2(int x) { int exp = 0; while (x \u0026gt;\u0026gt;= 1) exp += 1; return exp; } void init(int x, i64* v) { for (int i = 0; i \u0026lt;= x; i++) mx[i][0] = mn[i][0] = v[i]; for (int j = 1; 1 \u0026lt;\u0026lt; j \u0026lt;= x; j++) for (int i = 0; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= x; i++) { mx[i][j] = max(mx[i][j - 1], mx[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); mn[i][j] = min(mn[i][j - 1], mn[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]); } } i64 query_max(int l, int r) { if (l \u0026gt; r) return INT_MIN; int t = log2(r - l + 1); return max(mx[l][t], mx[r - (1 \u0026lt;\u0026lt; t) + 1][t]); } i64 query_min(int l, int r) { if (l \u0026gt; r) return INT_MAX; int t = log2(r - l + 1); return min(mn[l][t], mn[r - (1 \u0026lt;\u0026lt; t) + 1][t]); } }; int n, L, R; int a[N]; i64 ans[N], p[N]; SparseTable ST; void solve(int l, int r) { if (r - l + 1 \u0026lt; L) return; if (l == r) { if (L == 1) ans[l] = max(ans[l], (i64)a[l]); return; } int mid = (l + r) \u0026gt;\u0026gt; 1; solve(l, mid), solve(mid + 1, r); i64 pre = LLONG_MIN, suf = LLONG_MIN; for (int i = l; i \u0026lt;= mid; i++) { int x = max(i + L - 1, mid + 1); int y = min(i + R - 1, r); pre = max(pre, ST.query_max(x, y) - p[i - 1]); ans[i] = max(ans[i], pre); } for (int i = r; i \u0026gt; mid; i--) { int x = max(i - R + 1, l); int y = min(i - L + 1, mid); suf = max(suf, p[i] - ST.query_min(x - 1, y - 1)); ans[i] = max(ans[i], suf); } } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; L \u0026gt;\u0026gt; R; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i], p[i] = p[i - 1] + a[i], ans[i] = LLONG_MIN; ST.init(n, p); solve(1, n); for (int i = 1; i \u0026lt;= n; i++) cout \u0026lt;\u0026lt; ans[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; fflush(stdout); return 0; } Water Bottle 出处：JOISC 2014 Day 2 官方题面：日语 评测地址：AtCoder \u0026amp; LibreOJ #2876 参考题解：公式解说 看到题之后，很容易发现一个获取答案的方法。我们假设求的是从建筑物 $A$ 到建筑物 $B$ 的路上水瓶至少需要的容量。那么首先，最基础地，水瓶最大需要的容量便是从 $A$ 直接走到 $B$ 途中完全不打水的情况下两点之间的最短路长度 $-1$。那么如果存在一种方式，使得先从 $A$ 到某其他建筑物 $C$ 打水，再从 $C$ 到 $B$ 的过程从所需水瓶的最大容量比直接走所需要的最大容量要小，那么我们就认为这种方式更优。同理，在优化之后的路线上，我们还可以继续优化，直到找到最优解。\n前文中我们已经提到：从一个建筑物走到另一个建筑物上，如果不经过其他建筑物打水，那么途中需要消耗的水量就是两点之间的最短路长度 $-1$。也就是说，最优解的路径一定是一个或多个最短路的拼接，并且在这些最短路能够连通起点和终点的前提下，还要尽可能让这些最短路中的最大值尽可能小。这样说容易让人想到求最小生成树。实际上与最小生成树还是有区别的，因为不用连通所有的建筑物。但我们还是可以在这道题中应用 Kruskal 的思想。同时，由于用 LCA 在树上求最大边权的复杂度 $\\mathcal{O} \\left(\\log n\\right)$ 远低于在一般图上用 Dijkstra 求最短路和最大边权的复杂度 $\\mathcal{O} \\left(n \\log n\\right)$，故如果能把这张图化成一棵树，那么想必更有助于我们解决这道题。\n如何快速找到所有建筑物两两之间的最短距离？在本题中，整体复杂度较小且比较简单的方法之一是多源 BFS。具体来说，我们维护整个方格地图中每一个格子距离最近的建筑物的编号以及二者之间的距离。最初将所有建筑物一次性全部压入队列中，然后以这若干个建筑物为源点一层层地向外扩散。在从某个源点 $u$ 开始的搜索中，如果当前搜索到的格子还没有标记，说明距离该格子最近的建筑物就是 $u$；如果已经存在了某个其他源点 $v$ 的标记，说明已经到达了当前源点管辖范围的边界。由于 BFS 的性质，在当前状态、当前格子下，当前格子距离自己的源点 $u$ 的距离最短，距离当前格子的标记所属的源点 $v$ 的距离也最短，所以这两个最短距离的和便是从 $u$ 到 $v$ 的最短距离。\n我们得到了所有建筑物两两之间的最短距离后，接下来就是借助 Kruskal 算法思想的时候了。我们根据建筑物之间最短距离的长度，从小到大枚举所有的最短距离，并以最短距离长度为权值，在该最短距离沟通的两个建筑物之间连一条边。同一个连通块中的两个建筑物不重复连边。这样，当遍历完所有边之后，类似 Kruskal 构造最小生成树的原理，我们就建立了一片森林。这片森林中的每一棵树代表的连通块包含所有可连通的建筑物，并且树上的所有边中长度的最大值最小。树上求最短路问题复杂度就小很多了，对于每次询问，直接在这棵树上跑 LCA 求路径上的最大边权即可。\n代码实现方面，值得一提的是我们对多源 BFS 的结果转移到 LCA 过程中的处理。我们可以简单地开 $N^2 \\leqslant 4\\times 10^6$ 个 vector（在空间足够的情况下）当作桶，当出现搜索到其他源点管辖的格子时，我们将自己的源点和对方的源点都存入对应的 vector 中，也就是下标为当前格子到自己源点和到对方源点的两个最短距离之和的 vector 处，方便按照边权从小到大枚举。\n点击查看全部代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 #include \u0026lt;queue\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;numeric\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;algorithm\u0026gt; #define endl \u0026#39;\\n\u0026#39; using std::cin; using std::cout; using PII = std::pair\u0026lt;int, int\u0026gt;; const int MAX_N = 2e3 + 5; const int MAX_P = 2e5 + 5; const int dx[] = {0, 1, 0, -1}; const int dy[] = {1, 0, -1, 0}; int N, M, P, Q; char map[MAX_N][MAX_N]; std::queue\u0026lt;PII\u0026gt; q; int gov[MAX_N][MAX_N]; int dist[MAX_N][MAX_N]; std::vector\u0026lt;PII\u0026gt; graph[MAX_P]; std::vector\u0026lt;PII\u0026gt; graph2[MAX_N * MAX_N]; struct UnionFind { int fa[MAX_P]; void init(int x) { std::iota(fa, fa + x + 1, 0); } int find(int x) { if (fa[x] == x) return x; return fa[x] = find(fa[x]); } bool merge(int x, int y) { x = find(x), y = find(y); if (x == y) return false; return fa[x] = y, true; } } sets; namespace LCA { int fa[MAX_P][20]; int mx[MAX_P][20]; int depth[MAX_P]; void prep(int st) { std::queue\u0026lt;int\u0026gt; q; q.push(st); depth[st] = 1; while (!q.empty()) { int u = q.front(); q.pop(); for (auto [v, w] : graph[u]) { if (depth[v]) continue; depth[v] = depth[u] + 1; fa[v][0] = u, mx[v][0] = w; for (int i = 1; i \u0026lt; 20; i++) { fa[v][i] = fa[fa[v][i - 1]][i - 1]; mx[v][i] = std::max(mx[v][i - 1], mx[fa[v][i - 1]][i - 1]); } q.push(v); } } } int query(int u, int v) { if (depth[u] \u0026gt; depth[v]) std::swap(u, v); int mxw = 0; for (int i = 19; ~i; i--) if (depth[fa[v][i]] \u0026gt;= depth[u]) { mxw = std::max(mxw, mx[v][i]); v = fa[v][i]; } if (u == v) return mxw; for (int i = 19; ~i; i--) if (fa[u][i] != fa[v][i]) { mxw = std::max({mxw, mx[u][i], mx[v][i]}); u = fa[u][i], v = fa[v][i]; } mxw = std::max({mxw, mx[u][0], mx[v][0]}); return mxw; } } // namespace LCA int main() { std::ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; N \u0026gt;\u0026gt; M \u0026gt;\u0026gt; P \u0026gt;\u0026gt; Q; for (int i = 1; i \u0026lt;= N; i++) for (int j = 1; j \u0026lt;= M; j++) cin \u0026gt;\u0026gt; map[i][j]; for (int i = 1, x, y; i \u0026lt;= P; i++) { cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y; gov[x][y] = i; q.emplace(x, y); } while (!q.empty()) { auto [x, y] = q.front(); q.pop(); for (int i = 0; i \u0026lt; 4; i++) { int tx = x + dx[i]; int ty = y + dy[i]; if (tx \u0026lt; 1 || ty \u0026lt; 1 || tx \u0026gt; N || ty \u0026gt; M) continue; if (map[tx][ty] == \u0026#39;#\u0026#39;) continue; if (!gov[tx][ty]) { gov[tx][ty] = gov[x][y]; dist[tx][ty] = dist[x][y] + 1; q.emplace(tx, ty); } else if (gov[tx][ty] != gov[x][y]) graph2[dist[tx][ty] + dist[x][y]].emplace_back(gov[x][y], gov[tx][ty]); } } sets.init(P); for (int w = 0; w \u0026lt; N * N; w++) for (auto [u, v] : graph2[w]) if (sets.merge(u, v)) { graph[u].emplace_back(v, w); graph[v].emplace_back(u, w); } for (int i = 1; i \u0026lt;= P; i++) if (!LCA::depth[i]) LCA::prep(i); while (Q--) { int S, T; cin \u0026gt;\u0026gt; S \u0026gt;\u0026gt; T; if (sets.find(S) != sets.find(T)) cout \u0026lt;\u0026lt; -1 \u0026lt;\u0026lt; endl; else cout \u0026lt;\u0026lt; LCA::query(S, T) \u0026lt;\u0026lt; endl; } return fflush(stdout), 0; } Yet Another Array Counting Problem 出处：Codeforces Round 833 官方题面及评测地址：Codeforces 中文翻译：洛谷 RemoteJudge 参考题解：Official Editorial 我们令 $\\text{lmax}(i, j)$ 表示原序列 $a$ 的区间 $\\left[i, j\\right]$ 上 leftmost maximum 的位置。则可以得到一个结论，即对于任意子区间 $\\left[l, r\\right]$，令 $k = \\text{lmax}(l, r)$，则 $a_{\\text{lmax}(l, k - 1)} \u0026lt; a_k \\leqslant a_{\\text{lmax}(k + 1, r)}$（左半边不取等号是由 leftmost maximum 的性质决定的，请注意这一点在下面的分析以及代码实现中的体现）。\n根据上面的分析，我们发现 $\\text{lmax}$ 的取值范围是从更小的问题规模转移过来的，并且由于每个区间内的 $\\text{lmax}$ 的值是可以提前预处理出来的，因此我们可以考虑以当前问题规模 $\\left[l, r\\right]$ 的 leftmost maximum 值 $k = \\text{lmax}(l, r)$ 为中点进行分治来解决问题。\n我们令 $k = \\text{lmax}(l, r)$，则令 $f(k, j)$ 为当满足 $b_{\\text{lmax}(l, r)} = j$ 时组成 $b_l \\ldots b_r$ 的方案数。接下来思考如何转移。题目要求我们求所有子区间的 $\\text{lmax}$ 都与 $a$ 序列相同的 $b$ 序列的数量，其实说白了就是对于每一个确定的 $a$ 序列上的 $\\text{lmax}$，将其同时视为 $b$ 序列同一区间上的 $\\text{lmax}$ 后，以 $\\text{lmax}$ 为分界点的左右两边的总方案数之积（乘法原理）。由此可以分类讨论出以下几种情况：\n$b_{\\text{lmax}(l, r)} = 1$ 且左半边问题规模不为 $\\varnothing$ 时，根据定义，方案数为 $0$； $\\text{lmax}(l, r) = l$ 时，当前问题规模的左半边为 $\\varnothing$，此时方案数只考虑右半边； $\\text{lmax}(l, r) = r$ 时，当前问题规模的右半边为 $\\varnothing$，此时方案数只考虑左半边； $\\text{lmax}(l, r)$ 的左右半边问题规模都不为 $\\varnothing$ 时，此时方案数为左边总方案数和右边总方案数的积； $\\text{lmax}(l, r)$ 的左右半边问题规模都为 $\\varnothing$ 时，此时方案数为 $1$。 为了优化时间复杂度，我们需要随着递归过程维护总方案数 $g(k, j) = \\sum_{i = 1}^{j}f(k, i)$。\n综上，若令 $k = \\text{lmax}(l, r)$，$lc = \\text{lmax}(l, k - 1)$，$rc = \\text{lmax}(k + 1, r)$，则有：\n$$ f(k, j) = \\begin{cases} 0, \\quad \u0026amp;\\mathrm{if} ~ {b_{\\text{lmax}(l, r)} = 1} \\land {k \\neq l}\\newline 1, \\quad \u0026amp;\\mathrm{if} ~ {k = l = r} \\newline g(rc, j), \\quad \u0026amp;\\mathrm{if} ~ {k = l} \\newline g(lc, j - 1), \\quad \u0026amp;\\mathrm{if} ~ {k = r} \\newline g(lc, j - 1) \\cdot g(rc, j), \u0026amp;\\mathrm{otherwise.} \\end{cases} $$\n代码实现上，$\\text{lmax}$ 的函数值可以通过线段树、ST 表等数据结构实现查询；另一个需要小心的地方是不能一次性把 $f$ 和 $g$ 数组开成静态的，因为所需要的空间太大了，又会造成很多空间浪费（$n, m \\leqslant 2 \\times 10^5$，但 $nm \\leqslant 10^6$），因此需要采用开 vector 代替的方法进行替代。\n点击查看全部代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #include \u0026lt;vector\u0026gt; #include \u0026lt;cstring\u0026gt; #include \u0026lt;iostream\u0026gt; #define endl \u0026#39;\\n\u0026#39; using namespace std; using i64 = long long; const int N = 2e5 + 5; const int MOD = 1e9 + 7; int n, m, a[N]; vector\u0026lt;i64\u0026gt; f[N], g[N]; struct SparseTable { int tb[N][20]; int log2(int x) { int exp = 0; while (x \u0026gt;\u0026gt;= 1) exp += 1; return exp; } void prep() { int lmt = log2(n); for (int i = 1; i \u0026lt;= n; i++) { tb[i][0] = i; f[i].assign(m + 1, 0); g[i].assign(m + 1, 0); } for (int j = 1; j \u0026lt;= lmt; j++) for (int i = 1, x, y; i + (1 \u0026lt;\u0026lt; j) - 1 \u0026lt;= n; i++) if (a[x = tb[i][j - 1]] \u0026gt;= a[y = tb[i + (1 \u0026lt;\u0026lt; (j - 1))][j - 1]]) tb[i][j] = x; else tb[i][j] = y; } int max(int l, int r) { int t = log2(r - l + 1), x, y; if (a[x = tb[l][t]] \u0026gt;= a[y = tb[r - (1 \u0026lt;\u0026lt; t) + 1][t]]) return x; return y; } } ST; int divide_and_conquer(int l, int r) { if (l \u0026gt; r) return -1; int mid = ST.max(l, r); int lc = divide_and_conquer(l, mid - 1); int rc = divide_and_conquer(mid + 1, r); for (int i = 1; i \u0026lt;= m; i++) { if (lc != -1 \u0026amp;\u0026amp; i == 1) f[mid][1] = 0; else f[mid][i] = (lc != -1 ? g[lc][i - 1] : 1LL) * (rc != -1 ? g[rc][i] : 1LL) % MOD; g[mid][i] = (g[mid][i - 1] + f[mid][i]) % MOD; } return mid; } void solve() { cin \u0026gt;\u0026gt; n \u0026gt;\u0026gt; m; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; ST.prep(); int mid = divide_and_conquer(1, n); cout \u0026lt;\u0026lt; g[mid][m] \u0026lt;\u0026lt; endl; } int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int T; cin \u0026gt;\u0026gt; T; while (T--) solve(); return fflush(stdout), 0; } ","date":"2024-05-10T00:00:03+08:00","permalink":"https://eoin.blog/p/misc-solutions-1/","title":"杂题选解（一）"},{"content":" 模板题目：LibreOJ #103 或 洛谷 P3375 或 AcWing 831 求给定的字符串 $s$ 作为子串在另一个给定的字符串 $t$ 中所有出现的位置。\n朴素算法 对于这个问题，最朴素的方法莫过于暴力枚举，也就是分别从 $t$ 的每一个位置开始遍历，逐位比较当前字符与 $s$ 中对应字符是否相匹配。代码写起来很无脑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 string s, t; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int n = s.length(), m = t.length(); for (int i = 0; i \u0026lt; m - n; i++) { bool flag = true; for (int j = 0; j \u0026lt; n; j++) if (s[j] != t[i + j]) { flag = false; break; } if (flag) cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; endl; } return fflush(stdout), 0; } 以上代码的复杂度近似为 $\\mathcal{O}(nm)$，也就是两个字符串长度的乘积。在给出的模板题中，$1 \\leqslant n, m \\leqslant 10^6$，朴素算法显然是无法在时限内得出结果的。\n前缀函数 本节中，默认一个字符串的起始位置（下标）为 $0$。\n先来看看朴素算法具体是如何得出结果的。朴素算法的逻辑是，假如两个字符串之间出现了分歧，那么直接从头重新开始新一轮枚举。不过现在，假如我们可以根据已经遍历过的字符直接确定出接下来要把指针移动到什么位置去，就可以节省朴素算法每次将指针回退到开头、逐位枚举所造成的时间浪费。这就是接下来要介绍的 KMP 模式匹配算法降低复杂度的底层逻辑。不过在此之前，我们还要先引入前缀函数这样一个概念。\n对于字符串 $s$，可以构造一个数组 $\\pi$，其中每一个元素 $\\pi[i]$ 存储由 $s[0]$ 到 $s[i]$ 这 $i+1$ 个字符组成的子串中的真前缀与真后缀相等时它们的长度。\n比如字符串 ATAATA 可以构建出的 $\\pi$ 数组为 $\\left \\lbrace 0, 0, 1, 1, 2, 3 \\right \\rbrace$，这 $6$ 个数分别表示子串为 A、AT、ATA、ATAA、ATAAT 和 ATAATA 时，子串的真前缀与真后缀（字符串真前、后缀的概念，可以类比数组中前、后缀和以及集合论中真子集的概念）相等时它们的长度：\nA 没有真前缀和真后缀，存储为 $0$； AT 的真前缀与真后缀均不相等，存储为 $0$； ATA 的最长相等真前、后缀为 A，长度为 $1$； ATAA 的最长相等真前、后缀也为 A，长度为 $1$； ATAAT 的最长相等真前、后缀为 AT，长度为 $2$； ATAATA 的最长相等真前、后缀为 ATA，长度为 $3$。 这样的数组 $\\pi$，我们称之为字符串 $s$ 的前缀函数。\n然后拿 $s$ 与 $t$ 进行匹配，但是同时借助前缀函数来确定指针移动的位置。我们以 $s = \\texttt{ATAATA}$、$t = \\texttt{ATAAATAATA}$ 为例 。将 $i$ 与 $j$ 同时从各自字符串的开头向后移动，直到出现分歧。\n1 2 3 4 i ATAAATAATA ATAATA j 然后我们查看 $s$ 中分歧前一位的位置 $3$ 在 $\\pi$ 数组中存储的值，即 $\\pi[3] = 1$，再将 $j$ 移动到 $s$ 的 $1$ 位置：\n1 2 3 4 i ATAAATAATA ATAATA j 可以看到，这个时候，$s$ 中的第一个字符没有经过重新遍历就已经匹配上了！这是巧合吗？并不是。\n联系 $\\pi$ 数组的定义，我们可以发现，这一效果得以实现的原因是，分歧字符之前的 ATAA 这个子串的最长相等真前、后缀的长度为 $1$，也就是说，由于我们先前已经确认 $s$ 与 $t$ 的前 $4$ 个字符相同，其中最长相等真前、后缀的长度都为 $1$，即 $s$ 的第 $0$ 个位置和第 $3$ 个位置 、$t$ 的第 $0$ 个位置和第 $3$ 个位置的字符相同。那么那么出现分歧之后，就可以直接根据 $s$ 的第 $0$ 个位置的 A 与 $t$ 第 $3$ 个位置的 A 相匹配，把整个字符串向后移动到下一个位置，也就是把 $j$ 指针移动到 $\\pi[3] = 1$ 的位置。\n具体可以看下面的图示：\n从这个意义上来说，$\\pi$ 数组存储的值实际上是当前长度的子串中，最长相等真前、后缀的长度 $+1$ 之后在原子串里的位置。在这个位置之前的 $s$ 中第 $0$ 个位置一直到第 $\\pi[i]$ 个位置的所有字符所构成的子串，与 $t$ 中第 $i - \\pi[i]$ 个位置一直到第 $i - 1$ 个位置的所有字符所构成的子串，是完全相同的。因此我们可以把 $s[0] \\sim s[\\pi[i]]$ 移动到 $t[i-\\pi[i]] \\sim t[i-1]$ 的位置上（在图形中是把整个 $s$ 字符串向后移动，代码里通过调整 $j$ 指针位置来实现），而不需要重新去遍历之前的每一个字符。\n说了这么多，那么 $s$ 的前缀函数到底如何用程序计算出来呢？\n朴素算法显然可以很容易地解决这个问题，但是同样需要对 $s$ 进行两次扫描，时间复杂度约为 $\\mathcal{O}(n^2)$，显然是不过关的。我们还是可以用 $i$ 和 $j$ 指针向后移动的方法进行匹配，但是二者分别扫描各自的 $s$ 字符串，具体方法如下：（$s = \\texttt{ABACABA}$，$\\pi[0]$ 默认为 $0$）\n1 2 3 4 i ABACABA ABACABA j 我们从 $i=1, j = 0$ 开始扫描（$i$ 如果从头开始扫描，那么 $i$ 和 $j$ 扫描到的字符一定会匹配，因为本来就是两个相同的字符串在相互匹配） ，发现第一个字符就出现了分歧，这意味着 $\\pi[1] = 0$，因为 $i$ 后的所有字符所组成的后缀与 $j$ 及其之前所有字符组成的前缀并不相同。我们把 $0$ 存入 $\\pi[1]$ 的位置上，然后让 $i$ 向后移一位（$j$ 只在匹配到相同字符之后才向后移）。\n1 2 3 4 i ABACABA ABACABA j 两个位置相同，所以 $\\pi[2] = 1$，表示找到了 ABA 中的一个最长相等前、后缀 A，其长度为 $1$。然后就可以将 $i$ 与 $j$ 同时向后移动了。\n1 2 3 4 i ABACABA ABACABA j 显见这两个字符不同，此时我们需要在已有的 $\\pi$ 数组中查找，看能不能将 $j$ 所在的 $s$ 字符串向后移动到下一个匹配过的位置。这里的原理与实现方法，和前面提到的匹配 $t$ 与 $s$ 的原理和方法是一致的，我们查询 $\\pi$ 数组的目的，是为了节省朴素算法中从头开始遍历所浪费掉的时间。不过这里，由于 $\\pi[j-1] = \\pi[0] = 0$，意味着我们遍历过的字符中，找不到下一个字符来让我们直接移动 $j$ 指针以使 $j$ 所在的 $s$ 字符串开头与 $i$ 所在的 $s$ 字符串中遍历过的字符相匹配的位置了（$j$ 所在 $s$ 字符串前缀的 A 已经与 ABA 中后缀里的 A 的位置重合了）。所以我们还是把 $j$ 设为 $\\pi[0] = 0$，从 $j$ 所在 $s$ 字符串的开头重新开始遍历。\n1 2 3 4 i ABACABA ABACABA j 还是不匹配，设 $\\pi[3] = 0$。将 $i$ 向后移动。\n1 2 3 4 i ABACABA ABACABA j 发现匹配，设 $\\pi[4] = 1$。将 $i$ 和 $j$ 同时向后移动，直到结尾，就可以得出 $\\pi[5] = 2$ 和 $\\pi[6] = 3$。\n从上面的例子中，我们可以看出，如果不匹配，就将 $\\pi[i]$ 设为 $0$，仅移动 $i$ 指针，并且如果 $j \\ne 0$，就根据 $\\pi$ 数组中已有的值让 $j$ 指针向前返回到下一个可能出现匹配的位置；否则，$\\pi[i] = j +1$，也就是在之前最大长度的基础上加上这新遍历到的一个字符。\n这就是 KMP 模式匹配算法背后的原理。\n代码实现 综合一下之前的推理，我们可以把代码分成几个步骤：\n计算 $s$ 的前缀数组 $\\pi$： 如果当前位置字符不匹配，$j$ 指针回溯到下一个可能出现匹配的位置； 如果成功匹配，$j$ 指针移动到下一位； 存储 $\\pi[i]$ 的值。 在 $t$ 中查找 $s$： 如果当前位置字符不匹配，$j$ 指针回溯到下一个可能出现匹配的位置； 如果成功匹配，$j$ 指针移动到下一位； 如果 $j$ 指针已经成功到了 $s$ 串末尾，则输出所在位置并回溯到下一个可能出现匹配的位置（因为 $t$ 中的 $s$ 串可能重叠），继续匹配。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const int N = 1e6 + 10; int pi[N]; string s, t; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); cin \u0026gt;\u0026gt; s \u0026gt;\u0026gt; t; int n = s.length(), m = t.length(); for (int i = 1, j = 0; i \u0026lt; n; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; s[j] != s[i]) j = pi[j - 1]; if (s[j] == s[i]) j++; pi[i] = j; } for (int i = 0, j = 0; i \u0026lt; m; i++) { while (j \u0026gt; 0 \u0026amp;\u0026amp; t[i] != s[j]) j = pi[j - 1]; if (t[i] == s[j]) j++; if (j == n) { cout \u0026lt;\u0026lt; i - j + 1 \u0026lt;\u0026lt; \u0026#39; \u0026#39;; j = pi[j - 1]; } } return fflush(stdout), 0; } ","date":"2024-05-10T00:00:02+08:00","permalink":"https://eoin.blog/p/kmp-prefix-func/","title":"KMP 模式匹配算法与前缀函数"},{"content":" 模板题目：AcWing 896 典型例题：导弹拦截 朴素做法 最长上升子序列 (longest increasing subsequence, LIS) 问题的动态规划朴素思路为，针对给定序列中的每一个元素，计算一遍以该元素结尾的所有 LIS，并比较这些序列的长度，取得最大值。为了减小复杂度，计算每个元素结尾的 LIS 长度这一操作，我们通过动态规划提供的状态转移来实现，即根据以前一个元素结尾的 LIS 最大长度，对当前元素结尾的 LIS 的最大长度进行更新。根据这种思想可以写出以下的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const int N = 1e3 + 10; int a[N], dp[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; int ans = 0; for (int i = n; i \u0026gt;= 1; i--) { dp[i] = 1; for (int j = n; j \u0026gt; i; j--) if (a[i] \u0026lt; a[j]) dp[i] = max(dp[j] + 1, dp[i]); ans = max(dp[i], ans); } cout \u0026lt;\u0026lt; ans \u0026lt;\u0026lt; endl; return fflush(stdout), 0; } 可以大致分析，这种思路下，代码的复杂度达到了 $\\mathcal{O}(n^2)$，所以如果数据范围较大的话，就无法在时限内得出结果了。\n优化思路 如果说上面的思路还比较符合动态规划的思路，那么优化方式就需要换换脑筋，换用一种贪心的思路。考虑一个序列 $A = \\left \\lbrace 1, 2, 5, 4, 3, 4\\right \\rbrace$，并维护一个序列 $F$，每一个元素 $F_i$ 存储长度为 $i$ 的 LIS 中末尾元素的最小值。这样做的好处在于，在遍历 $A$ 中元素时，假如遍历到的元素比 $F$ 中的所有元素都要大，那么恭喜，这个序列的 LIS 就可以增加一个元素了；假如遍历到的元素比 $F$ 中的某个元素要小，就用当前元素覆盖掉第一个大于或等于它的元素，在给剩下的元素留出更大空间的同时，也不会影响 LIS 的长度。\n这么说可能有点抽象，不如拿实际的例子来说明，更加直观。\n我们令序列中的下标从 $1$ 开始。\n当 $i = 1$ 时，对于 $A_1 = 1$，长度为 $i = 1$ 的 LIS 的末尾元素最小当然只能是 $1$，所以将 $F_1$ 的值设为 $1$； 当 $i = 2$ 时，对于 $A_2 = 2$，由于目前 $F$ 中还没有比 $2$ 大的元素，所以把它放到 $F_2$，作为长度为 $2$ 的 LIS 末尾的最小元素； 当 $i = 3$ 时，对于 $A_3 = 5$，由于目前 $F$ 中还没有比 $5$ 大的元素，所以把它放到 $F_3$，作为长度为 $3$ 的 LIS 末尾的最小元素； 当 $i = 4$ 时，对于 $A_4 = 4$，它比 $F_3 = 5$ 要小，所以为了给后加入的元素腾空间，就把 $F_3$ 的值更新为 $4$； 当 $i = 5$ 时，对于 $A_5 = 3$，它比 $F_3 = 4$ 要小，所以为了给后加入的元素腾空间，就把 $F_3$ 的值更新为 $3$； 当 $i = 6$ 时，对于 $A_6 = 4$，由于目前 $F$ 中还没有比 $4$ 大的元素，所以把它放到 $F_4$，作为长度为 $4$ 的 LIS 末尾的最小元素。 看到这里，你可能已经发现之前我们设计 $F$ 序列及有关一系列操作的意义了。\n如果不进行覆盖，在上面说 $i = 4$ 的时候没有替换掉原来的 $5$，那么当遍历到 $A_6 = 4$ 的时候，你会发现 $4$ 就无法添加到 LIS 末尾元素的序列中，也就无法得出 LIS 的正确长度了。将原序列中的更小元素存入 $F$ 序列，就能给后来的元素腾出更多的空间，从而尽可能加长 LIS。\n但是，按照朴素写法，这种思路的复杂度依然是 $\\mathcal{O}(n^2)$，所以还需要挖掘我们维护的 $F$ 序列所具有的性质来选取合适的算法以降低复杂度。按照我们对 $F$ 序列的描述，加上上面例子的解释，不难发现，$F$ 序列是单调递增的。而对于具有单调性的、需要查找某一个元素（要查找 $F$ 中第一个比 $A_i$ 大的元素）的问题，常用的解决方法就是二分了。（如果不替换第一个比 $A_i$ 大的元素，而是替换成了后面的数，就会破坏 $F$ 序列的单调性，导致无法使用二分解题。）\n$\\mathbf{F}$ 序列单调性的证明\n假设存在 $i \u0026lt; j$，满足 $F_i \\geqslant F_j$，则序列 $A$ 中一定有一个以 $F_j$ 结尾的 LIS，那么显然可以从该 $F_j$ 为结尾的 LIS 中不断删除末尾元素，直到留下一个长度为 $i$ 的 LIS，这个新 LIS 的末尾元素一定小于 $F_j$，所以也一定小于 $F_i$。但根据我们的定义，这个新 LIS 的末尾元素应当为 $F_i$，但它同时比 $F_i$ 小，因此产生矛盾，所以 $F_i \\geqslant F_j$ 不成立，原序列单调递增。\n不过这也会引出一个问题：为什么我们要覆盖掉这个大于等于 $A_i$ 的元素，而不是将更大的元素向后挪一位呢？后者明明也不会破坏 $F$ 序列的单调性。还是拿 $A = \\left \\lbrace 1, 2, 5, 4, 3, 4\\right \\rbrace$ 这个序列举例：如果我们在遍历到 $A_i = 4$ 时，将 $F_3 = 5$ 向后挪到 $F_4 = 5$，将 $A_i = 4$ 插入到了 $F_3$ 的位置上，那么显然 $5$ 不可能成为一个长度为 $4$ 的 LIS 的末尾元素，因为原序列中 $5$ 及之前一共都只有 $3$ 个元素。放大到任意一个序列 $A$ 来讲，由于我们遍历到 $A$ 中的每一个元素都只考虑其之前的元素所构成的 LIS，如果将 $F$ 中元素向后移动，就会导致 $F$ 中被移动的值无法构成合法的 LIS。\n代码实现 根据这样的思路，可以写出如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 const int N = 1e5 + 10; int a[N], f[N]; int main() { ios::sync_with_stdio(false); cin.tie(nullptr); int n; cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) cin \u0026gt;\u0026gt; a[i]; int len = 0; for (int i = 1; i \u0026lt;= n; i++) { int l = 1, r = len + 1; while (l \u0026lt; r) { int mid = (l + r) \u0026gt;\u0026gt; 1; if (f[mid] \u0026gt;= a[i]) r = mid; else l = mid + 1; } len = max(len, l); f[l] = a[i]; } cout \u0026lt;\u0026lt; len \u0026lt;\u0026lt; endl; return fflush(stdout), 0; } 由于二分的复杂度在对数级别，所以算法的总复杂度就降低到了 $\\mathcal{O}(n \\log n)$，即可处理更大的数据范围。\n","date":"2024-05-10T00:00:01+08:00","permalink":"https://eoin.blog/p/lis-w-binary-search/","title":"最长上升子序列问题的二分优化"},{"content":"拓扑排序 (topological sorting) 要解决的问题是给一个有向无环图 (directed acyclic graph, DAG) 的所有节点排序。概括地来说，拓扑排序对所有节点进行排序的依据是节点之间的指向关系，所以只有有向图有拓扑排序。在实际问题中，图中有向边的方向可以具体地理解为事物之间的依赖关系或者先后顺序。因此，当依赖关系出现循环等问题的时候，也就是有向图中出现环的时候，就无法进行拓扑排序。一个图能进行拓扑排序的充要条件是它有向且无环。\n对于一个有向无环图 $G = \\left(V, E\\right)$，如果一个无重复元素的序列 $a$ 满足 $\\forall u \\in V, u \\in a$，且 $\\forall (u \\rightarrow v) \\in E$，$u$ 在序列中先于 $v$ 出现，则 $a$ 为 $G$ 的一个合法拓扑序。\n以上图中所示的 DAG 为例，一个合法的拓扑序为 $\\left \\lbrace 1, 2, 4, 5, 3 \\right \\rbrace$。\nBFS 求拓扑序 从时间复杂度角度以及常数角度着想，我们通常通过 BFS 求拓扑排序，这一算法最初由 A. Kahn 提出。首先，在一个集合中加入图中所有入度为 $0$ 的节点，这些节点没有前驱，所以一定是依赖链的最底层；接着，从集合中取出某一个元素，基于该节点进行扩展，将其所有的后继节点的入度 $-1$。重复此操作，直到某一个后继节点的入度降为 $0$。这时，这个后继节点的所有前驱就可以确保全部遍历完了，因此将该节点加入集合中，继续进行拓扑排序，直到队列为空为止。如果这样的操作完全作用于一个 DAG 上，则节点从队首或栈顶取出的顺序就是该 DAG 的一个合法的拓扑序列，其中每一个节点都出现在其所有前驱的后面。\n如果上述操作被执行在一个有环图上，则最终得到的序列会出现以下几种情况：\n最初加入集合时，找不到任何入度为 $0$ 的节点，说明图中一定有环； 所得序列所包含的节点数小于总节点数，说明在排序过程中在遍历完所有点之前集合就空了，说明这些点的入度均不为 $0$，则图中一定有环，并且没有进入集合的点就是环路上的点，因为从外界无法进入环路，自然也无法把环路上的点的入度降低为 $0$。 可以根据上述两条性质判断是否存在环并获取图中环上的节点。\n由于拓扑排序的最终结果是将所有节点的入度全部降低至 $0$，而入度的总和就是边的总数，所以通过 BFS 求拓扑排序的时间复杂度为 $\\mathcal{O}\\left(V + E\\right)$。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 vector\u0026lt;int\u0026gt; topological_sort(int n) { queue\u0026lt;int\u0026gt; q; vector\u0026lt;int\u0026gt; seq; for (int u = 1; u \u0026lt;= n; u++) if (in[u] == 0) q.push(u); while (!q.empty()) { int u = q.front(); q.pop(); seq.push_back(u); for (int v : edges[u]) if (--in[v] == 0) q.push(v); } return seq; } DFS 求拓扑序 还有一种通过 DFS 求拓扑排序的方法。这种方法不需要直接统计每个节点的度数。它的原理是不断从节点集中取出节点，并从该节点开始，对所有子节点进行 DFS，并在当前节点的所有子节点全部搜索完成之后将该节点插入序列中。由于子节点的搜索一定在当前节点被插入序列之前完成，所以最终得到的序列是一个合法的逆拓扑序，将其进行翻转即可得到一个合法的拓扑序。\n由于每个节点最多被搜索一次，且每条边也最多被遍历一次，所以该算法的整体时间复杂度同样是 $\\mathcal{O}\\left(V + E\\right)$。当然，在实际程序实现中，DFS 还需要考虑递归带来的额外时间消耗，所以使用常数较小的 BFS 还是更加常见的选择。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void DFS(int u, vector\u0026lt;int\u0026gt;\u0026amp; seq) { vis[u] = true; for (int v : edges[u]) if (!vis[v]) DFS(v, seq); seq.push_back(u); } vector\u0026lt;int\u0026gt; topological_sort() { vector\u0026lt;int\u0026gt; seq; for (int u = 1; u \u0026lt;= n; u++) if (!vis[u]) DFS(u, seq); reverse(seq.begin(), seq.end()); return seq; } ","date":"2024-05-10T00:00:00+08:00","permalink":"https://eoin.blog/p/topological-sorting/","title":"拓扑排序及其两种实现"}]